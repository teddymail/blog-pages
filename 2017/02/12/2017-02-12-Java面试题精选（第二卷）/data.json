{"title":"Java面试题精选（第二卷）","date":"2017-02-12T09:33:24.000Z","source":"_posts/2017-02-12.Java面试题精选（第二卷）.md","raw":"---\ntitle: Java面试题精选（第二卷）\ndate: 2017-02-12 17:33:24\ntags: Java\n---\n\n1. 进程和线程的区别是什么？\n\n> ###### 答：\n>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。\n\n---\n\n2. 创建线程有几种不同的方式？你喜欢哪一种？为什么？\n\n> ###### 答：\n\n>有三种方式可以用来创建线程：\n>1.继承Thread类\n>2.实现Runnable接口\n>3.应用程序可以使用Executor框架来创建线程池\n>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。\n\n---\n\n3.概括的解释下线程的几种可用状态。\n\n> ###### 答：\n>1. 新建( new )：新创建了一个线程对象。\n>2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。\n>3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。\n>4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：\n>>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( >>waitting queue )中。\n>>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。\n>>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。\n>5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生\n>![线程图例](http://img.yuekang.org.cn/2017021202_thread.png)\n\n---\n4.同步方法和同步代码块的区别是什么？\n\n> ###### 答：\n>区别：\n>同步方法默认用this或者当前类class对象作为锁；\n>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法.\n\n---\n5.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？\n\n> ###### 答：\n\n>监视器和锁在Java虚拟机中是一块使用的。\n>监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。\n>每一个监视器都和一个对象引用相关联。\n>线程在获取锁之前不允许执行同步代码。\n\n---\n6.什么是死锁(deadlock)？\n\n> ###### 答：\n>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。\n\n---\n7.如何确保N个线程可以访问N个资源同时又不导致死锁？\n\n> ###### 答：\n>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。\n\n---\n8.Java集合类框架的基本接口有哪些？\n\n> ###### 答:\n>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。\n>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。\n>Java集合类里面最基本的接口有：\n>>1.Collection：代表一组对象，每一个对象都是它的子元素。\n>>2.Set：不包含重复元素的Collection。\n>>3.List：有顺序的collection，并且可以包含重复元素。\n>>4.Map：可以把键(key)映射到值(value)的对象，键不能重复。\n\n---\n9.为什么集合类没有实现Cloneable和Serializable接口？\n\n> ###### 答:\n>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。\n\n---\n10.什么是迭代器(Iterator)？\n\n> ###### 答:\n>Iterator接口提供了很多对集合元素进行迭代的方法。\n>每一个集合类都包含了可以返回迭代器实例的迭代方法。\n>迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。\n","slug":"2017-02-12-Java面试题精选（第二卷）","published":true,"updated":"2024-09-02T09:06:11.417Z","_id":"cm0oplavg0003uysn9hh73thc","comments":true,"layout":"post","photos":[],"html":"<ol>\n<li>进程和线程的区别是什么？</li>\n</ol>\n<blockquote>\n<h6 id=\"答：\"><a href=\"#答：\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>\n</blockquote>\n<hr>\n<ol start=\"2\">\n<li>创建线程有几种不同的方式？你喜欢哪一种？为什么？</li>\n</ol>\n<blockquote>\n<h6 id=\"答：-1\"><a href=\"#答：-1\" class=\"headerlink\" title=\"答：\"></a>答：</h6></blockquote>\n<blockquote>\n<p>有三种方式可以用来创建线程：<br>1.继承Thread类<br>2.实现Runnable接口<br>3.应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>\n</blockquote>\n<hr>\n<p>3.概括的解释下线程的几种可用状态。</p>\n<blockquote>\n<h6 id=\"答：-2\"><a href=\"#答：-2\" class=\"headerlink\" title=\"答：\"></a>答：</h6><ol>\n<li>新建( new )：新创建了一个线程对象。</li>\n<li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>\n<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li>\n<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<blockquote>\n<p>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( &gt;&gt;waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I &#x2F; O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I &#x2F; O 处理完毕时，线程重新转入可运行( runnable )状态。</p>\n</blockquote>\n</li>\n<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生<br><img src=\"http://img.yuekang.org.cn/2017021202_thread.png\" alt=\"线程图例\"></li>\n</ol>\n</blockquote>\n<hr>\n<p>4.同步方法和同步代码块的区别是什么？</p>\n<blockquote>\n<h6 id=\"答：-3\"><a href=\"#答：-3\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>区别：<br>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法.</p>\n</blockquote>\n<hr>\n<p>5.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</p>\n<blockquote>\n<h6 id=\"答：-4\"><a href=\"#答：-4\" class=\"headerlink\" title=\"答：\"></a>答：</h6></blockquote>\n<blockquote>\n<p>监视器和锁在Java虚拟机中是一块使用的。<br>监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。<br>每一个监视器都和一个对象引用相关联。<br>线程在获取锁之前不允许执行同步代码。</p>\n</blockquote>\n<hr>\n<p>6.什么是死锁(deadlock)？</p>\n<blockquote>\n<h6 id=\"答：-5\"><a href=\"#答：-5\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p>\n</blockquote>\n<hr>\n<p>7.如何确保N个线程可以访问N个资源同时又不导致死锁？</p>\n<blockquote>\n<h6 id=\"答：-6\"><a href=\"#答：-6\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>\n</blockquote>\n<hr>\n<p>8.Java集合类框架的基本接口有哪些？</p>\n<blockquote>\n<h6 id=\"答\"><a href=\"#答\" class=\"headerlink\" title=\"答:\"></a>答:</h6><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。<br>Java集合类里面最基本的接口有：</p>\n<blockquote>\n<p>1.Collection：代表一组对象，每一个对象都是它的子元素。<br>2.Set：不包含重复元素的Collection。<br>3.List：有顺序的collection，并且可以包含重复元素。<br>4.Map：可以把键(key)映射到值(value)的对象，键不能重复。</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>9.为什么集合类没有实现Cloneable和Serializable接口？</p>\n<blockquote>\n<h6 id=\"答-1\"><a href=\"#答-1\" class=\"headerlink\" title=\"答:\"></a>答:</h6><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p>\n</blockquote>\n<hr>\n<p>10.什么是迭代器(Iterator)？</p>\n<blockquote>\n<h6 id=\"答-2\"><a href=\"#答-2\" class=\"headerlink\" title=\"答:\"></a>答:</h6><p>Iterator接口提供了很多对集合元素进行迭代的方法。<br>每一个集合类都包含了可以返回迭代器实例的迭代方法。<br>迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p>\n</blockquote>\n","excerpt":"","more":"<ol>\n<li>进程和线程的区别是什么？</li>\n</ol>\n<blockquote>\n<h6 id=\"答：\"><a href=\"#答：\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>\n</blockquote>\n<hr>\n<ol start=\"2\">\n<li>创建线程有几种不同的方式？你喜欢哪一种？为什么？</li>\n</ol>\n<blockquote>\n<h6 id=\"答：-1\"><a href=\"#答：-1\" class=\"headerlink\" title=\"答：\"></a>答：</h6></blockquote>\n<blockquote>\n<p>有三种方式可以用来创建线程：<br>1.继承Thread类<br>2.实现Runnable接口<br>3.应用程序可以使用Executor框架来创建线程池<br>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p>\n</blockquote>\n<hr>\n<p>3.概括的解释下线程的几种可用状态。</p>\n<blockquote>\n<h6 id=\"答：-2\"><a href=\"#答：-2\" class=\"headerlink\" title=\"答：\"></a>答：</h6><ol>\n<li>新建( new )：新创建了一个线程对象。</li>\n<li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li>\n<li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li>\n<li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：<blockquote>\n<p>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( &gt;&gt;waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I &#x2F; O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I &#x2F; O 处理完毕时，线程重新转入可运行( runnable )状态。</p>\n</blockquote>\n</li>\n<li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生<br><img src=\"http://img.yuekang.org.cn/2017021202_thread.png\" alt=\"线程图例\"></li>\n</ol>\n</blockquote>\n<hr>\n<p>4.同步方法和同步代码块的区别是什么？</p>\n<blockquote>\n<h6 id=\"答：-3\"><a href=\"#答：-3\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>区别：<br>同步方法默认用this或者当前类class对象作为锁；<br>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法.</p>\n</blockquote>\n<hr>\n<p>5.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</p>\n<blockquote>\n<h6 id=\"答：-4\"><a href=\"#答：-4\" class=\"headerlink\" title=\"答：\"></a>答：</h6></blockquote>\n<blockquote>\n<p>监视器和锁在Java虚拟机中是一块使用的。<br>监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。<br>每一个监视器都和一个对象引用相关联。<br>线程在获取锁之前不允许执行同步代码。</p>\n</blockquote>\n<hr>\n<p>6.什么是死锁(deadlock)？</p>\n<blockquote>\n<h6 id=\"答：-5\"><a href=\"#答：-5\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p>\n</blockquote>\n<hr>\n<p>7.如何确保N个线程可以访问N个资源同时又不导致死锁？</p>\n<blockquote>\n<h6 id=\"答：-6\"><a href=\"#答：-6\" class=\"headerlink\" title=\"答：\"></a>答：</h6><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>\n</blockquote>\n<hr>\n<p>8.Java集合类框架的基本接口有哪些？</p>\n<blockquote>\n<h6 id=\"答\"><a href=\"#答\" class=\"headerlink\" title=\"答:\"></a>答:</h6><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。<br>Java集合类里面最基本的接口有：</p>\n<blockquote>\n<p>1.Collection：代表一组对象，每一个对象都是它的子元素。<br>2.Set：不包含重复元素的Collection。<br>3.List：有顺序的collection，并且可以包含重复元素。<br>4.Map：可以把键(key)映射到值(value)的对象，键不能重复。</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>9.为什么集合类没有实现Cloneable和Serializable接口？</p>\n<blockquote>\n<h6 id=\"答-1\"><a href=\"#答-1\" class=\"headerlink\" title=\"答:\"></a>答:</h6><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p>\n</blockquote>\n<hr>\n<p>10.什么是迭代器(Iterator)？</p>\n<blockquote>\n<h6 id=\"答-2\"><a href=\"#答-2\" class=\"headerlink\" title=\"答:\"></a>答:</h6><p>Iterator接口提供了很多对集合元素进行迭代的方法。<br>每一个集合类都包含了可以返回迭代器实例的迭代方法。<br>迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。</p>\n</blockquote>\n","path":"2017/02/12/2017-02-12-Java面试题精选（第二卷）/","permalink":"https://yuekang.org.cn/2017/02/12/2017-02-12-Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%89/","tags":[{"name":"Java","_id":"cm0oplavi0004uysnbrlsfonp","slug":"Java","path":"tags/Java/","permalink":"https://yuekang.org.cn/tags/Java/","length":5}],"categories":[],"prev":{"title":"Java中的知识点（区别）","date":"2017-02-13T00:58:14.000Z","slug":"2017-02-13-Java中的知识点（区别）","published":true,"updated":"2024-09-02T09:06:11.418Z","_id":"cm0oplavk0006uysnc664foar","layout":"post","photos":[],"excerpt":"","path":"2017/02/13/2017-02-13-Java中的知识点（区别）/","permalink":"https://yuekang.org.cn/2017/02/13/2017-02-13-Java%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8C%BA%E5%88%AB%EF%BC%89/","__post":true},"next":{"title":"Java面试题精选(第一卷)","date":"2017-02-11T19:32:19.000Z","slug":"2017-02-12-Java面试题精选-第一卷","published":true,"updated":"2024-09-02T09:06:11.417Z","_id":"cm0oplavd0001uysnfuf8hmwq","layout":"post","photos":[],"excerpt":"","path":"2017/02/12/2017-02-12-Java面试题精选-第一卷/","permalink":"https://yuekang.org.cn/2017/02/12/2017-02-12-Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89-%E7%AC%AC%E4%B8%80%E5%8D%B7/","__post":true},"__post":true}