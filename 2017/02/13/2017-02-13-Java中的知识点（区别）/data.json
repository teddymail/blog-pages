{"title":"Java中的知识点（区别）","date":"2017-02-13T00:58:14.000Z","source":"_posts/2017-02-13.Java中的知识点（区别）.md","raw":"---\ntitle: Java中的知识点（区别）\ndate: 2017-02-13 08:58:14\ntags: [Java,面试题]\ndesc: Java中的知识点（区别）\n---\n\n1.public ,private, protected 不写时候的区别:\n\n|作用于|   当前类    |   同包   |   子孙类   |   其他package   |\n|:----|:----:|:-----:|:-----:|:----:|\n|public|√|√|√|√|\n|protected|√|√|√|×|\n|friendly|√|√|×|×|\n|private|√|×|×|×|\n\n>不写时默认为friendly\n\n2.Collection和Collections的区别\n\n>答：\n>1.java.util.Collection是一个`集合接口`。它提供了集合对象进行基本操作的通用接口方法。\nCollection接口在java类库中有很多具体的实现。Collection接口意义是为各种具体的集合提供了最大化的统一操作方式。\n```java\nCollection   \n├List   \n│├LinkedList   \n│├ArrayList   \n│└Vector   \n│　└Stack   \n└Set\n```\n>java.util.Collections是一个包装类。它包含有各种有关集合操作的`静态多态方法`。此类`不能实例化`,就像一各工具类，服务于java的Collection框架\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\npublic class TestCollections {\n  public static void main(String args[]) {\n\t\t//注意List是实现Collection接口的\n    List list = new ArrayList();\n    double array[] = { 112, 111, 23, 456, 231 };\n    for (int i = 0; i < array.length; i++) {\n      list.add(new Double(array[i]));\n    }\n    Collections.sort(list);\n    for (int i = 0; i < array.length; i++) {\n      System.out.println(list.get(i));\n    }\n    // 结果：23.0 111.0 112.0 231.0 456.0\n\t}\n}\n```\n\n3.Vector类和ArrayList类的区别\n\n>答：\n>`Vector`和`ArrayList`同属于`List`接口下,Vector从java1开始一直沿用至今，他俩的最大区别之处是加入了同步锁的策略，Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。\n\n4.String和StringBuffer的区别\n\n>答:\n>String 类代表字符串。Java 程序中的所有字符串字面值（如 \"abc\" ）都作为此类的实例实现。\n>我们查看内部源码\n```java\npublic final class String\n  implements java.io.Serializable, Comparable<String>, CharSequence {...}\n```\n>查看源码的关键字'final'内部则是维护一个不可改变的数组，所以不可以动态的扩种添加，只能创建一个更大的对象来装载新添加的数据\n\n>下面我们来看一下'StringBuffer'的官方源代码\n```java\npublic final class StringBuffer\n  extends AbstractStringBuilder\n  implements java.io.Serializable, Appendable, CharSequence\n{\n  public StringBuffer(String str) {\n        super(str.length() + 16);\n        append(str);\n  }\n}\n```\n\n>从这里看出我们实际上增加字符串的过程实际上就是调用了自身的`append`方法而已，追查具体的实现\n\n```java\npublic AbstractStringBuilder append(String str) {\n    if (str == null) str = \"null\";\n    int len = str.length();\n    ensureCapacityInternal(count + len);\n    str.getCharsNoCheck(0, len, value, count);\n    count += len;\n    return this;\n }\n```\n\n>实际上是计算当前字符串的长度，并且通过计数器把最新存储的位置保存下来，之前还需要判空,`ensureCapacityInternal(count + len);`就是他们的动态扩展数组大小的具体实现，其原理就是判断当前存储的的位数是否足够，不够就动态的空中。\n","slug":"2017-02-13-Java中的知识点（区别）","published":true,"updated":"2024-09-02T09:06:11.418Z","_id":"cm0w4eg0p0006etsn6z659uxj","comments":true,"layout":"post","photos":[],"html":"<p>1.public ,private, protected 不写时候的区别:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">作用于</th>\n<th align=\"center\">当前类</th>\n<th align=\"center\">同包</th>\n<th align=\"center\">子孙类</th>\n<th align=\"center\">其他package</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"left\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n</tr>\n<tr>\n<td align=\"left\">friendly</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n</tr>\n<tr>\n<td align=\"left\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>不写时默认为friendly</p>\n</blockquote>\n<p>2.Collection和Collections的区别</p>\n<blockquote>\n<p>答：<br>1.java.util.Collection是一个<code>集合接口</code>。它提供了集合对象进行基本操作的通用接口方法。<br>Collection接口在java类库中有很多具体的实现。Collection接口意义是为各种具体的集合提供了最大化的统一操作方式。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection   </span><br><span class=\"line\">├List   </span><br><span class=\"line\">│├LinkedList   </span><br><span class=\"line\">│├ArrayList   </span><br><span class=\"line\">│└Vector   </span><br><span class=\"line\">│　└Stack   </span><br><span class=\"line\">└Set</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>java.util.Collections是一个包装类。它包含有各种有关集合操作的<code>静态多态方法</code>。此类<code>不能实例化</code>,就像一各工具类，服务于java的Collection框架</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCollections</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注意List是实现Collection接口的</span></span><br><span class=\"line\">    <span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">    <span class=\"type\">double</span> array[] = &#123; <span class=\"number\">112</span>, <span class=\"number\">111</span>, <span class=\"number\">23</span>, <span class=\"number\">456</span>, <span class=\"number\">231</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(array[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collections.sort(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">      System.out.println(list.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结果：23.0 111.0 112.0 231.0 456.0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.Vector类和ArrayList类的区别</p>\n<blockquote>\n<p>答：<br><code>Vector</code>和<code>ArrayList</code>同属于<code>List</code>接口下,Vector从java1开始一直沿用至今，他俩的最大区别之处是加入了同步锁的策略，Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>\n</blockquote>\n<p>4.String和StringBuffer的区别</p>\n<blockquote>\n<p>答:<br>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>我们查看内部源码</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>查看源码的关键字’final’内部则是维护一个不可改变的数组，所以不可以动态的扩种添加，只能创建一个更大的对象来装载新添加的数据</p>\n</blockquote>\n<blockquote>\n<p>下面我们来看一下’StringBuffer’的官方源代码</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringBuffer</span></span><br><span class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractStringBuilder</span></span><br><span class=\"line\">  <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Appendable, CharSequence</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">StringBuffer</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(str.length() + <span class=\"number\">16</span>);</span><br><span class=\"line\">        append(str);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>从这里看出我们实际上增加字符串的过程实际上就是调用了自身的<code>append</code>方法而已，追查具体的实现</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> AbstractStringBuilder <span class=\"title function_\">append</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span>) str = <span class=\"string\">&quot;null&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> str.length();</span><br><span class=\"line\">    ensureCapacityInternal(count + len);</span><br><span class=\"line\">    str.getCharsNoCheck(<span class=\"number\">0</span>, len, value, count);</span><br><span class=\"line\">    count += len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>实际上是计算当前字符串的长度，并且通过计数器把最新存储的位置保存下来，之前还需要判空,<code>ensureCapacityInternal(count + len);</code>就是他们的动态扩展数组大小的具体实现，其原理就是判断当前存储的的位数是否足够，不够就动态的空中。</p>\n</blockquote>\n","excerpt":"","more":"<p>1.public ,private, protected 不写时候的区别:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">作用于</th>\n<th align=\"center\">当前类</th>\n<th align=\"center\">同包</th>\n<th align=\"center\">子孙类</th>\n<th align=\"center\">其他package</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"left\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n</tr>\n<tr>\n<td align=\"left\">friendly</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n</tr>\n<tr>\n<td align=\"left\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n<td align=\"center\">×</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>不写时默认为friendly</p>\n</blockquote>\n<p>2.Collection和Collections的区别</p>\n<blockquote>\n<p>答：<br>1.java.util.Collection是一个<code>集合接口</code>。它提供了集合对象进行基本操作的通用接口方法。<br>Collection接口在java类库中有很多具体的实现。Collection接口意义是为各种具体的集合提供了最大化的统一操作方式。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection   </span><br><span class=\"line\">├List   </span><br><span class=\"line\">│├LinkedList   </span><br><span class=\"line\">│├ArrayList   </span><br><span class=\"line\">│└Vector   </span><br><span class=\"line\">│　└Stack   </span><br><span class=\"line\">└Set</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>java.util.Collections是一个包装类。它包含有各种有关集合操作的<code>静态多态方法</code>。此类<code>不能实例化</code>,就像一各工具类，服务于java的Collection框架</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collections;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCollections</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注意List是实现Collection接口的</span></span><br><span class=\"line\">    <span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">    <span class=\"type\">double</span> array[] = &#123; <span class=\"number\">112</span>, <span class=\"number\">111</span>, <span class=\"number\">23</span>, <span class=\"number\">456</span>, <span class=\"number\">231</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">      list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Double</span>(array[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collections.sort(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">      System.out.println(list.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结果：23.0 111.0 112.0 231.0 456.0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.Vector类和ArrayList类的区别</p>\n<blockquote>\n<p>答：<br><code>Vector</code>和<code>ArrayList</code>同属于<code>List</code>接口下,Vector从java1开始一直沿用至今，他俩的最大区别之处是加入了同步锁的策略，Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>\n</blockquote>\n<p>4.String和StringBuffer的区别</p>\n<blockquote>\n<p>答:<br>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。<br>我们查看内部源码</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>查看源码的关键字’final’内部则是维护一个不可改变的数组，所以不可以动态的扩种添加，只能创建一个更大的对象来装载新添加的数据</p>\n</blockquote>\n<blockquote>\n<p>下面我们来看一下’StringBuffer’的官方源代码</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringBuffer</span></span><br><span class=\"line\">  <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractStringBuilder</span></span><br><span class=\"line\">  <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Appendable, CharSequence</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">StringBuffer</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(str.length() + <span class=\"number\">16</span>);</span><br><span class=\"line\">        append(str);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>从这里看出我们实际上增加字符串的过程实际上就是调用了自身的<code>append</code>方法而已，追查具体的实现</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> AbstractStringBuilder <span class=\"title function_\">append</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span>) str = <span class=\"string\">&quot;null&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> str.length();</span><br><span class=\"line\">    ensureCapacityInternal(count + len);</span><br><span class=\"line\">    str.getCharsNoCheck(<span class=\"number\">0</span>, len, value, count);</span><br><span class=\"line\">    count += len;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>实际上是计算当前字符串的长度，并且通过计数器把最新存储的位置保存下来，之前还需要判空,<code>ensureCapacityInternal(count + len);</code>就是他们的动态扩展数组大小的具体实现，其原理就是判断当前存储的的位数是否足够，不够就动态的空中。</p>\n</blockquote>\n","path":"2017/02/13/2017-02-13-Java中的知识点（区别）/","permalink":"https://yuekang.org.cn/2017/02/13/2017-02-13-Java%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8C%BA%E5%88%AB%EF%BC%89/","tags":[{"name":"Java","_id":"cm0w4eg0n0004etsnat476pwb","slug":"Java","path":"tags/Java/","permalink":"https://yuekang.org.cn/tags/Java/","length":5},{"name":"面试题","_id":"cm0w4eg0y000letsn2izgdkl0","slug":"面试题","path":"tags/面试题/","permalink":"https://yuekang.org.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/","length":2}],"categories":[],"prev":{"title":"安卓开源库推荐","date":"2017-03-01T06:22:08.000Z","slug":"2017-03-01-安卓开源库推荐","published":true,"updated":"2024-09-08T06:12:12.613Z","_id":"cm0w4eg0q0007etsn0tzeef4q","layout":"post","photos":[],"excerpt":"","path":"2017/03/01/2017-03-01-安卓开源库推荐/","permalink":"https://yuekang.org.cn/2017/03/01/2017-03-01-%E5%AE%89%E5%8D%93%E5%BC%80%E6%BA%90%E5%BA%93%E6%8E%A8%E8%8D%90/","__post":true},"next":{"title":"Java面试题精选（第二卷）","date":"2017-02-12T09:33:24.000Z","slug":"2017-02-12-Java面试题精选（第二卷）","published":true,"updated":"2024-09-08T06:15:22.957Z","_id":"cm0w4eg0l0003etsnbm4406vq","layout":"post","photos":[],"excerpt":"","path":"2017/02/12/2017-02-12-Java面试题精选（第二卷）/","permalink":"https://yuekang.org.cn/2017/02/12/2017-02-12-Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%8D%B7%EF%BC%89/","__post":true},"__post":true}