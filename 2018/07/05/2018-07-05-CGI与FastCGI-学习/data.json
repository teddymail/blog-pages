{"title":"CGI与FastCGI 学习","date":"2018-07-05T15:16:00.000Z","source":"_posts/2018-07-05.CGI与FastCGI_学习.md","raw":"---\ntitle: CGI与FastCGI 学习\ndate: 2018-07-05 23:16:00\ntags: [PHP,CGI,FastCGI]\n---\n\n>CGI:是 Web Server 与 Web Application 之间数据交换的一种协议。\n>FastCGI:同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。\n>PHP-CGI:是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。\n>PHP-FPM:是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理\n\n# CGI工作流程\n\n1. 如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。\n\n2. 当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。\n\n# FastCGI工作流程\n\n1.如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。\n\n2.当Web Server收到 index.php 这个请求后,FastCGI程序(FastCGI在启动时就初始化执行执行环境，每个CGI进程池各个CGI进程共享执行环境)在CGI进程池中选择一个CGI进程处理请求，再以规定CGI规定的格式返回处理后的结果，继续等待下一个请求。\n\n# PHP-FPM基本实现\n\n1.PHP-FPM的实现就是创建一个master进程，在master进程中创建worker pool并让其监听socket，然后fork出多个子进程(work)，这些子进程各自accept请求，子进程的处理非常简单，它在启动后阻塞在accept上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说PHP-FPM的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求\n\n2.PHP-FPM的master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等，当master进程要杀掉一个worker进程时则通过发送信号的方式通知worker进程。\n\n3.PHP-FPM可以同时监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程\n\n![](http://img.yuekang.org.cn/blog/images/2018070501.png)\n\n## Worker工作流程\n\n1.等待请求： worker进程阻塞在fcgi_accept_request()等待请求；\n2.解析请求： fastcgi请求到达后被worker接收，然后开始接收并解析请求数据，直到request数据完全到达；\n3.请求初始化： 执行php_request_startup()，此阶段会调用每个扩展的：PHP_RINIT_FUNCTION()；\n4.编译、执行： 由php_execute_script()完成PHP脚本的编译、执行；\n5.关闭请求： 请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。\n\n","slug":"2018-07-05-CGI与FastCGI-学习","published":true,"updated":"2024-09-08T06:12:12.699Z","_id":"cm0q19pfb001pw8sn7wpvgbin","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>CGI:是 Web Server 与 Web Application 之间数据交换的一种协议。<br>FastCGI:同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。<br>PHP-CGI:是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。<br>PHP-FPM:是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理</p>\n</blockquote>\n<h1 id=\"CGI工作流程\"><a href=\"#CGI工作流程\" class=\"headerlink\" title=\"CGI工作流程\"></a>CGI工作流程</h1><ol>\n<li><p>如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p>\n</li>\n<li><p>当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。</p>\n</li>\n</ol>\n<h1 id=\"FastCGI工作流程\"><a href=\"#FastCGI工作流程\" class=\"headerlink\" title=\"FastCGI工作流程\"></a>FastCGI工作流程</h1><p>1.如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p>\n<p>2.当Web Server收到 index.php 这个请求后,FastCGI程序(FastCGI在启动时就初始化执行执行环境，每个CGI进程池各个CGI进程共享执行环境)在CGI进程池中选择一个CGI进程处理请求，再以规定CGI规定的格式返回处理后的结果，继续等待下一个请求。</p>\n<h1 id=\"PHP-FPM基本实现\"><a href=\"#PHP-FPM基本实现\" class=\"headerlink\" title=\"PHP-FPM基本实现\"></a>PHP-FPM基本实现</h1><p>1.PHP-FPM的实现就是创建一个master进程，在master进程中创建worker pool并让其监听socket，然后fork出多个子进程(work)，这些子进程各自accept请求，子进程的处理非常简单，它在启动后阻塞在accept上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说PHP-FPM的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求</p>\n<p>2.PHP-FPM的master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等，当master进程要杀掉一个worker进程时则通过发送信号的方式通知worker进程。</p>\n<p>3.PHP-FPM可以同时监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程</p>\n<p><img src=\"http://img.yuekang.org.cn/blog/images/2018070501.png\"></p>\n<h2 id=\"Worker工作流程\"><a href=\"#Worker工作流程\" class=\"headerlink\" title=\"Worker工作流程\"></a>Worker工作流程</h2><p>1.等待请求： worker进程阻塞在fcgi_accept_request()等待请求；<br>2.解析请求： fastcgi请求到达后被worker接收，然后开始接收并解析请求数据，直到request数据完全到达；<br>3.请求初始化： 执行php_request_startup()，此阶段会调用每个扩展的：PHP_RINIT_FUNCTION()；<br>4.编译、执行： 由php_execute_script()完成PHP脚本的编译、执行；<br>5.关闭请求： 请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>\n","excerpt":"","more":"<blockquote>\n<p>CGI:是 Web Server 与 Web Application 之间数据交换的一种协议。<br>FastCGI:同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。<br>PHP-CGI:是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。<br>PHP-FPM:是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理</p>\n</blockquote>\n<h1 id=\"CGI工作流程\"><a href=\"#CGI工作流程\" class=\"headerlink\" title=\"CGI工作流程\"></a>CGI工作流程</h1><ol>\n<li><p>如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p>\n</li>\n<li><p>当Web Server收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。</p>\n</li>\n</ol>\n<h1 id=\"FastCGI工作流程\"><a href=\"#FastCGI工作流程\" class=\"headerlink\" title=\"FastCGI工作流程\"></a>FastCGI工作流程</h1><p>1.如果客户端请求的是 index.html，那么Web Server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。</p>\n<p>2.当Web Server收到 index.php 这个请求后,FastCGI程序(FastCGI在启动时就初始化执行执行环境，每个CGI进程池各个CGI进程共享执行环境)在CGI进程池中选择一个CGI进程处理请求，再以规定CGI规定的格式返回处理后的结果，继续等待下一个请求。</p>\n<h1 id=\"PHP-FPM基本实现\"><a href=\"#PHP-FPM基本实现\" class=\"headerlink\" title=\"PHP-FPM基本实现\"></a>PHP-FPM基本实现</h1><p>1.PHP-FPM的实现就是创建一个master进程，在master进程中创建worker pool并让其监听socket，然后fork出多个子进程(work)，这些子进程各自accept请求，子进程的处理非常简单，它在启动后阻塞在accept上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说PHP-FPM的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求</p>\n<p>2.PHP-FPM的master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等，当master进程要杀掉一个worker进程时则通过发送信号的方式通知worker进程。</p>\n<p>3.PHP-FPM可以同时监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程</p>\n<p><img src=\"http://img.yuekang.org.cn/blog/images/2018070501.png\"></p>\n<h2 id=\"Worker工作流程\"><a href=\"#Worker工作流程\" class=\"headerlink\" title=\"Worker工作流程\"></a>Worker工作流程</h2><p>1.等待请求： worker进程阻塞在fcgi_accept_request()等待请求；<br>2.解析请求： fastcgi请求到达后被worker接收，然后开始接收并解析请求数据，直到request数据完全到达；<br>3.请求初始化： 执行php_request_startup()，此阶段会调用每个扩展的：PHP_RINIT_FUNCTION()；<br>4.编译、执行： 由php_execute_script()完成PHP脚本的编译、执行；<br>5.关闭请求： 请求完成后执行php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤(1)等待下一个请求。</p>\n","path":"2018/07/05/2018-07-05-CGI与FastCGI-学习/","permalink":"https://yuekang.org.cn/2018/07/05/2018-07-05-CGI%E4%B8%8EFastCGI-%E5%AD%A6%E4%B9%A0/","tags":[{"name":"PHP","_id":"cm0q19pf40018w8snarzydr0l","slug":"PHP","path":"tags/PHP/","permalink":"https://yuekang.org.cn/tags/PHP/","length":10},{"name":"CGI","_id":"cm0q19pg2004vw8sncu55ca96","slug":"CGI","path":"tags/CGI/","permalink":"https://yuekang.org.cn/tags/CGI/","length":1},{"name":"FastCGI","_id":"cm0q19pg2004yw8sn0o4y22k5","slug":"FastCGI","path":"tags/FastCGI/","permalink":"https://yuekang.org.cn/tags/FastCGI/","length":1}],"categories":[],"prev":{"title":"CentOS7 安装OpenLdap","date":"2018-07-08T07:02:30.000Z","slug":"2018-07-08-CentOS7-安装OpenLdap","published":true,"updated":"2024-09-08T06:12:12.617Z","_id":"cm0q19pfb001rw8sn7lj3fvva","layout":"post","photos":[],"excerpt":"","path":"2018/07/08/2018-07-08-CentOS7-安装OpenLdap/","permalink":"https://yuekang.org.cn/2018/07/08/2018-07-08-CentOS7-%E5%AE%89%E8%A3%85OpenLdap/","__post":true},"next":{"title":"find,locate查找文件","date":"2018-07-04T14:41:39.000Z","slug":"2018-07-04-find-locate查找文件","published":true,"updated":"2024-09-02T09:06:11.426Z","_id":"cm0q19pfa001mw8snf0tjd5e8","layout":"post","photos":[],"excerpt":"","path":"2018/07/04/2018-07-04-find-locate查找文件/","permalink":"https://yuekang.org.cn/2018/07/04/2018-07-04-find-locate%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/","__post":true},"__post":true}