{"title":"php共享内存学习","date":"2018-02-05T03:43:37.000Z","source":"_posts/2018-02-05.php共享内存学习.md","raw":"---\ntitle: php共享内存学习\ndate: 2018-02-05 11:43:37\ntags: [php,shared-memory]\n---\n\n>php中进程间通信介绍的很少，今天我来学习学习怎么实现共享内存的实现\n\n* 安装\n\n[安装地址](http://php.net/manual/zh/shmop.installation.php)\n\n需要在安装的时候添加 **--enable-shmop** 来启用该函数的功能\n\n可以通过 ** phpinfo(); ** 来确认是否安装成功，我这里查看 ** shmop support => enabled ** 代表启用成功了\n\n* 主要函数\n\n```php7\nshmop_close — 关闭共享内存块\nshmop_delete — 删除共享内存块\nshmop_open — 创建或打开共享内存块\nshmop_read — 从共享内存块中读取数据\nshmop_size — 获取共享内存块的大小\nshmop_write — 向共享内存块中写入数据\n```\n>与此相关的还有一个很重要的函数：[ftok](http://php.net/manual/zh/function.ftok.php)，通过文件的 inode 信息（**nix** 上通过 **stat** 或 **ls -i** 命令查看）创建 IPC 的唯一 key（文件/文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。\n\n有个需要稍微注意的点：shmop_open 的第二个参数是个 flag，类似 fopen 的第二个参数，其取值有以前几个：\n\n```\n“a” 只读访问\n“c” 如果内存片段不存在，则创建，如果存在，则可读写；\n\n“w” 读写；\n\n“n” 创建新的内存片段，如果同样 key 的已存在，则会创建失败，这是为了安全使用共享内存考虑。\n```\n\n* 程序\n\n```php\n//新建一块共享内存（并取得唯一nodeID）\n$shm_key = ftok(__FILE__,'t');\n//打开改共享内存文件，采用片段不存在则创建策略\n$shm_id = shmop_open($shm_key,'c',0644,8);\n# 读取读取共享内存（8字节读取）\n$count = (int) shmop_read($shm_id, 0, 8) + 1;\n\nshmop_write($shm_id, str_pad($count, 8, '0', STR_PAD_LEFT), 0);\necho $count;\nshmop_close($shm_id);\n\n```\n\n* 运行效果图\n\n>即使进程关闭重新开启依然能够正常读取数据！\n\n\n![效果图](http://img.yuekang.org.cn/20180205150620.png)\n\n\n> 一定要把握长度，否则可能出现读取异常的问题\n","slug":"2018-02-05-php共享内存学习","published":true,"updated":"2024-09-02T09:06:11.422Z","_id":"cm0p50fup0016oxsnhk2mdpcw","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>php中进程间通信介绍的很少，今天我来学习学习怎么实现共享内存的实现</p>\n</blockquote>\n<ul>\n<li>安装</li>\n</ul>\n<p><a href=\"http://php.net/manual/zh/shmop.installation.php\">安装地址</a></p>\n<p>需要在安装的时候添加 <strong>–enable-shmop</strong> 来启用该函数的功能</p>\n<p>可以通过 ** phpinfo(); ** 来确认是否安装成功，我这里查看 ** shmop support &#x3D;&gt; enabled ** 代表启用成功了</p>\n<ul>\n<li>主要函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shmop_close — 关闭共享内存块</span><br><span class=\"line\">shmop_delete — 删除共享内存块</span><br><span class=\"line\">shmop_open — 创建或打开共享内存块</span><br><span class=\"line\">shmop_read — 从共享内存块中读取数据</span><br><span class=\"line\">shmop_size — 获取共享内存块的大小</span><br><span class=\"line\">shmop_write — 向共享内存块中写入数据</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>与此相关的还有一个很重要的函数：<a href=\"http://php.net/manual/zh/function.ftok.php\">ftok</a>，通过文件的 inode 信息（<strong>nix</strong> 上通过 <strong>stat</strong> 或 <strong>ls -i</strong> 命令查看）创建 IPC 的唯一 key（文件&#x2F;文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。</p>\n</blockquote>\n<p>有个需要稍微注意的点：shmop_open 的第二个参数是个 flag，类似 fopen 的第二个参数，其取值有以前几个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“a” 只读访问</span><br><span class=\"line\">“c” 如果内存片段不存在，则创建，如果存在，则可读写；</span><br><span class=\"line\"></span><br><span class=\"line\">“w” 读写；</span><br><span class=\"line\"></span><br><span class=\"line\">“n” 创建新的内存片段，如果同样 key 的已存在，则会创建失败，这是为了安全使用共享内存考虑。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>程序</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建一块共享内存（并取得唯一nodeID）</span></span><br><span class=\"line\"><span class=\"variable\">$shm_key</span> = <span class=\"title function_ invoke__\">ftok</span>(<span class=\"keyword\">__FILE__</span>,<span class=\"string\">&#x27;t&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//打开改共享内存文件，采用片段不存在则创建策略</span></span><br><span class=\"line\"><span class=\"variable\">$shm_id</span> = <span class=\"title function_ invoke__\">shmop_open</span>(<span class=\"variable\">$shm_key</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"number\">0644</span>,<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\"># 读取读取共享内存（8字节读取）</span></span><br><span class=\"line\"><span class=\"variable\">$count</span> = (<span class=\"keyword\">int</span>) <span class=\"title function_ invoke__\">shmop_read</span>(<span class=\"variable\">$shm_id</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">shmop_write</span>(<span class=\"variable\">$shm_id</span>, <span class=\"title function_ invoke__\">str_pad</span>(<span class=\"variable\">$count</span>, <span class=\"number\">8</span>, <span class=\"string\">&#x27;0&#x27;</span>, STR_PAD_LEFT), <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"variable\">$count</span>;</span><br><span class=\"line\"><span class=\"title function_ invoke__\">shmop_close</span>(<span class=\"variable\">$shm_id</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行效果图</li>\n</ul>\n<blockquote>\n<p>即使进程关闭重新开启依然能够正常读取数据！</p>\n</blockquote>\n<p><img src=\"http://img.yuekang.org.cn/20180205150620.png\" alt=\"效果图\"></p>\n<blockquote>\n<p>一定要把握长度，否则可能出现读取异常的问题</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>php中进程间通信介绍的很少，今天我来学习学习怎么实现共享内存的实现</p>\n</blockquote>\n<ul>\n<li>安装</li>\n</ul>\n<p><a href=\"http://php.net/manual/zh/shmop.installation.php\">安装地址</a></p>\n<p>需要在安装的时候添加 <strong>–enable-shmop</strong> 来启用该函数的功能</p>\n<p>可以通过 ** phpinfo(); ** 来确认是否安装成功，我这里查看 ** shmop support &#x3D;&gt; enabled ** 代表启用成功了</p>\n<ul>\n<li>主要函数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shmop_close — 关闭共享内存块</span><br><span class=\"line\">shmop_delete — 删除共享内存块</span><br><span class=\"line\">shmop_open — 创建或打开共享内存块</span><br><span class=\"line\">shmop_read — 从共享内存块中读取数据</span><br><span class=\"line\">shmop_size — 获取共享内存块的大小</span><br><span class=\"line\">shmop_write — 向共享内存块中写入数据</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>与此相关的还有一个很重要的函数：<a href=\"http://php.net/manual/zh/function.ftok.php\">ftok</a>，通过文件的 inode 信息（<strong>nix</strong> 上通过 <strong>stat</strong> 或 <strong>ls -i</strong> 命令查看）创建 IPC 的唯一 key（文件&#x2F;文件夹的 inode 是唯一的）。这个函数在 Linux 上也是直接调用同名的系统函数实现，Windows 上还是使用一些封装。</p>\n</blockquote>\n<p>有个需要稍微注意的点：shmop_open 的第二个参数是个 flag，类似 fopen 的第二个参数，其取值有以前几个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">“a” 只读访问</span><br><span class=\"line\">“c” 如果内存片段不存在，则创建，如果存在，则可读写；</span><br><span class=\"line\"></span><br><span class=\"line\">“w” 读写；</span><br><span class=\"line\"></span><br><span class=\"line\">“n” 创建新的内存片段，如果同样 key 的已存在，则会创建失败，这是为了安全使用共享内存考虑。</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>程序</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//新建一块共享内存（并取得唯一nodeID）</span></span><br><span class=\"line\"><span class=\"variable\">$shm_key</span> = <span class=\"title function_ invoke__\">ftok</span>(<span class=\"keyword\">__FILE__</span>,<span class=\"string\">&#x27;t&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//打开改共享内存文件，采用片段不存在则创建策略</span></span><br><span class=\"line\"><span class=\"variable\">$shm_id</span> = <span class=\"title function_ invoke__\">shmop_open</span>(<span class=\"variable\">$shm_key</span>,<span class=\"string\">&#x27;c&#x27;</span>,<span class=\"number\">0644</span>,<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\"># 读取读取共享内存（8字节读取）</span></span><br><span class=\"line\"><span class=\"variable\">$count</span> = (<span class=\"keyword\">int</span>) <span class=\"title function_ invoke__\">shmop_read</span>(<span class=\"variable\">$shm_id</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">shmop_write</span>(<span class=\"variable\">$shm_id</span>, <span class=\"title function_ invoke__\">str_pad</span>(<span class=\"variable\">$count</span>, <span class=\"number\">8</span>, <span class=\"string\">&#x27;0&#x27;</span>, STR_PAD_LEFT), <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"variable\">$count</span>;</span><br><span class=\"line\"><span class=\"title function_ invoke__\">shmop_close</span>(<span class=\"variable\">$shm_id</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行效果图</li>\n</ul>\n<blockquote>\n<p>即使进程关闭重新开启依然能够正常读取数据！</p>\n</blockquote>\n<p><img src=\"http://img.yuekang.org.cn/20180205150620.png\" alt=\"效果图\"></p>\n<blockquote>\n<p>一定要把握长度，否则可能出现读取异常的问题</p>\n</blockquote>\n","path":"2018/02/05/2018-02-05-php共享内存学习/","permalink":"https://yuekang.org.cn/2018/02/05/2018-02-05-php%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/","tags":[{"name":"php","_id":"cm0p50fvg0032oxsn9rci0b9m","slug":"php","path":"tags/php/","permalink":"https://yuekang.org.cn/tags/php/","length":5},{"name":"shared-memory","_id":"cm0p50fvh003hoxsn7e5hg9q7","slug":"shared-memory","path":"tags/shared-memory/","permalink":"https://yuekang.org.cn/tags/shared-memory/","length":2}],"categories":[],"prev":{"title":"php信号量控制","date":"2018-02-05T07:33:01.000Z","slug":"2018-02-05-php信号量控制","published":true,"updated":"2024-09-02T09:06:11.423Z","_id":"cm0p50fuo0013oxsn0sn0f6cl","layout":"post","photos":[],"excerpt":"","path":"2018/02/05/2018-02-05-php信号量控制/","permalink":"https://yuekang.org.cn/2018/02/05/2018-02-05-php%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6/","__post":true},"next":{"title":"spring boot配置多环境","date":"2017-12-20T06:00:58.000Z","slug":"2017-12-20-spring-boot配置多环境","published":true,"updated":"2024-09-02T09:06:11.422Z","_id":"cm0p50fum000zoxsnhnvieq1b","layout":"post","photos":[],"excerpt":"","path":"2017/12/20/2017-12-20-spring-boot配置多环境/","permalink":"https://yuekang.org.cn/2017/12/20/2017-12-20-spring-boot%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%8E%AF%E5%A2%83/","__post":true},"__post":true}