{"title":"PHP7- I/O模型学习","date":"2018-06-21T14:38:44.000Z","source":"_posts/2018-06-21.PHP7-_IO模型学习.md","raw":"---\ntitle: PHP7- I/O模型学习\ndate: 2018-06-21 22:38:44\ntags: [PHP7,IO]\n---\n\n>四种响应模型\n>1. 同步：调用后，死等，等到结果为止\n>2. 异步：调用立即返回，等到有结果通知\n>3. 阻塞：数据没有处理完成前不返回\n>4. 非阻塞：调用立即返回等到有结果通知我\n\n# 五种I/O模型\n\n1. 阻塞I/O (Blocking I/O)\n\n![阻塞I/O](http://img.yuekang.org.cn/2018062101.png)\n\n当进程进行系统调用时，内核开始了IO的第一个阶段准备数据，准备完成交给内核缓冲最后拷贝到用户进程的内存中，然后才解锁进程，这个等待过程称为阻塞。\n\n\n2. 非阻塞I/O (Non-Blocking I/O)\n\n![非阻塞I/O](http://img.yuekang.org.cn/2018062102.png)\n\n进程在第二阶段被阻塞，\b调用的时候没有阻塞，\b第二阶段开始不断轮训CPU询问数据是否准备完毕，所以比较消耗CPU资源的模型\n\n3. I/O复用（I/O Multiplexing)\n\n![I/O复用](http://img.yuekang.org.cn/2018062103.png)\n\nIO执行的两个阶段进程都是阻塞的，在这次完整的过程中，进程发起了两次系统调用。和阻塞IO不同的\b是第一阶段可以等待多个\b调用结果\n\n4. 信号驱动的I/O (Signal Driven I/O)\n\n![信号驱动的I/O](http://img.yuekang.org.cn/2018062104.png)\n\n只有在IO执行的第二阶段阻塞了进程，该模型在IO执行的第一阶段，当数据完成之后，会主动通知进程数据已经准备好，对进程做一个回调，通知分为两种，一位水平触发，及时进程不响应会一直发送通知，二为边缘触发，即只通知一次\n\n5. 异步I/O (Asynchrnous I/O)\n\n![异步I/O](http://img.yuekang.org.cn/2018062105.png)\n\n当进程发起系统调用后，立刻就可以开始做其它事情，然后知道IO执行的两个阶段都完成之后，内核会给集成发送通知，告之进程已经完成处理了。","slug":"2018-06-21-PHP7-IO模型学习","published":true,"updated":"2024-09-02T09:06:11.426Z","_id":"cm0p50fuu001ioxsnhvxz34nv","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>四种响应模型</p>\n<ol>\n<li>同步：调用后，死等，等到结果为止</li>\n<li>异步：调用立即返回，等到有结果通知</li>\n<li>阻塞：数据没有处理完成前不返回</li>\n<li>非阻塞：调用立即返回等到有结果通知我</li>\n</ol>\n</blockquote>\n<h1 id=\"五种I-O模型\"><a href=\"#五种I-O模型\" class=\"headerlink\" title=\"五种I&#x2F;O模型\"></a>五种I&#x2F;O模型</h1><ol>\n<li>阻塞I&#x2F;O (Blocking I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062101.png\" alt=\"阻塞I/O\"></p>\n<p>当进程进行系统调用时，内核开始了IO的第一个阶段准备数据，准备完成交给内核缓冲最后拷贝到用户进程的内存中，然后才解锁进程，这个等待过程称为阻塞。</p>\n<ol start=\"2\">\n<li>非阻塞I&#x2F;O (Non-Blocking I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062102.png\" alt=\"非阻塞I/O\"></p>\n<p>进程在第二阶段被阻塞，\b调用的时候没有阻塞，\b第二阶段开始不断轮训CPU询问数据是否准备完毕，所以比较消耗CPU资源的模型</p>\n<ol start=\"3\">\n<li>I&#x2F;O复用（I&#x2F;O Multiplexing)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062103.png\" alt=\"I/O复用\"></p>\n<p>IO执行的两个阶段进程都是阻塞的，在这次完整的过程中，进程发起了两次系统调用。和阻塞IO不同的\b是第一阶段可以等待多个\b调用结果</p>\n<ol start=\"4\">\n<li>信号驱动的I&#x2F;O (Signal Driven I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062104.png\" alt=\"信号驱动的I/O\"></p>\n<p>只有在IO执行的第二阶段阻塞了进程，该模型在IO执行的第一阶段，当数据完成之后，会主动通知进程数据已经准备好，对进程做一个回调，通知分为两种，一位水平触发，及时进程不响应会一直发送通知，二为边缘触发，即只通知一次</p>\n<ol start=\"5\">\n<li>异步I&#x2F;O (Asynchrnous I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062105.png\" alt=\"异步I/O\"></p>\n<p>当进程发起系统调用后，立刻就可以开始做其它事情，然后知道IO执行的两个阶段都完成之后，内核会给集成发送通知，告之进程已经完成处理了。</p>\n","excerpt":"","more":"<blockquote>\n<p>四种响应模型</p>\n<ol>\n<li>同步：调用后，死等，等到结果为止</li>\n<li>异步：调用立即返回，等到有结果通知</li>\n<li>阻塞：数据没有处理完成前不返回</li>\n<li>非阻塞：调用立即返回等到有结果通知我</li>\n</ol>\n</blockquote>\n<h1 id=\"五种I-O模型\"><a href=\"#五种I-O模型\" class=\"headerlink\" title=\"五种I&#x2F;O模型\"></a>五种I&#x2F;O模型</h1><ol>\n<li>阻塞I&#x2F;O (Blocking I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062101.png\" alt=\"阻塞I/O\"></p>\n<p>当进程进行系统调用时，内核开始了IO的第一个阶段准备数据，准备完成交给内核缓冲最后拷贝到用户进程的内存中，然后才解锁进程，这个等待过程称为阻塞。</p>\n<ol start=\"2\">\n<li>非阻塞I&#x2F;O (Non-Blocking I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062102.png\" alt=\"非阻塞I/O\"></p>\n<p>进程在第二阶段被阻塞，\b调用的时候没有阻塞，\b第二阶段开始不断轮训CPU询问数据是否准备完毕，所以比较消耗CPU资源的模型</p>\n<ol start=\"3\">\n<li>I&#x2F;O复用（I&#x2F;O Multiplexing)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062103.png\" alt=\"I/O复用\"></p>\n<p>IO执行的两个阶段进程都是阻塞的，在这次完整的过程中，进程发起了两次系统调用。和阻塞IO不同的\b是第一阶段可以等待多个\b调用结果</p>\n<ol start=\"4\">\n<li>信号驱动的I&#x2F;O (Signal Driven I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062104.png\" alt=\"信号驱动的I/O\"></p>\n<p>只有在IO执行的第二阶段阻塞了进程，该模型在IO执行的第一阶段，当数据完成之后，会主动通知进程数据已经准备好，对进程做一个回调，通知分为两种，一位水平触发，及时进程不响应会一直发送通知，二为边缘触发，即只通知一次</p>\n<ol start=\"5\">\n<li>异步I&#x2F;O (Asynchrnous I&#x2F;O)</li>\n</ol>\n<p><img src=\"http://img.yuekang.org.cn/2018062105.png\" alt=\"异步I/O\"></p>\n<p>当进程发起系统调用后，立刻就可以开始做其它事情，然后知道IO执行的两个阶段都完成之后，内核会给集成发送通知，告之进程已经完成处理了。</p>\n","path":"2018/06/21/2018-06-21-PHP7-IO模型学习/","permalink":"https://yuekang.org.cn/2018/06/21/2018-06-21-PHP7-IO%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0/","tags":[{"name":"PHP7","_id":"cm0p50fvi003uoxsn4wvmcwsf","slug":"PHP7","path":"tags/PHP7/","permalink":"https://yuekang.org.cn/tags/PHP7/","length":4},{"name":"IO","_id":"cm0p50fvk004foxsn2mxe7r8o","slug":"IO","path":"tags/IO/","permalink":"https://yuekang.org.cn/tags/IO/","length":1}],"categories":[],"prev":{"title":"yar学习","date":"2018-06-24T11:48:51.000Z","slug":"2018-06-24-yar学习","published":true,"updated":"2024-09-02T09:06:11.426Z","_id":"cm0p50fuv001koxsn6bic2dlt","layout":"post","photos":[],"excerpt":"","path":"2018/06/24/2018-06-24-yar学习/","permalink":"https://yuekang.org.cn/2018/06/24/2018-06-24-yar%E5%AD%A6%E4%B9%A0/","__post":true},"next":{"title":"array常用函数整理","date":"2018-06-19T14:25:39.000Z","slug":"2018-06-19-array常用函数整理","published":true,"updated":"2024-09-02T09:06:11.426Z","_id":"cm0p50fut001hoxsn4umh48td","layout":"post","photos":[],"excerpt":"","path":"2018/06/19/2018-06-19-array常用函数整理/","permalink":"https://yuekang.org.cn/2018/06/19/2018-06-19-array%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/","__post":true},"__post":true}