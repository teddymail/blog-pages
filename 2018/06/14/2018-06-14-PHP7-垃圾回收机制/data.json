{"title":"PHP7-垃圾回收机制","date":"2018-06-14T13:30:01.000Z","source":"_posts/2018-06-14.PHP7-垃圾回收机制.md","raw":"---\ntitle: PHP7-垃圾回收机制\ndate: 2018-06-14 21:30:01\ntags: [PHP,PHP7,垃圾回收]\n---\n\n> 垃圾回收是一种自动的内存管理机制，当一个变量在程序中不再被使用时，应该予以释放，这种内存资源管理称为垃圾回收。其中一种垃圾回收方式是使用引用计数，通过对数据存储的物理空间多附加一个计数器空间，当其他数据与其相关是，计数器加一，反之，相关解除时计数器减一。定期检查各存储对象的计数器，计数器为零的话，则认为该对象已经被抛弃而应将其所占物理空间回收。\n\n下面是GC的核心数据结构:\n```c\nstruct _zend_refcounted {\n    uint32_t refcount;\n    union {\n        struct {\n            ZEND_ENDIAN_LOHI_3(\n                zend_uchar    type,\n                zend_uchar    flags,\n                uint16_t      gc_info)\n        } v;\n        uint32_t type_info;\n    } u;\n};\n```\n\n![zend_refcounted_h的结构](http://img.yuekang.org.cn/2018061401.png)\n\nzend_refcounted由32位bit的refcount和32bit的type_info组成\n\n\b1. type 第一个字节记录当前元素的类型\n\n2. flags 第二个字节用来记录数据类型\n\n3. gc_info 后面的两个字节标记当前元素的颜色和垃圾回收池中的位置，其中高地址的两位用来标记颜色。\n\n3.1 颜色有 黑色，白色，灰色，紫色\n\nphp性能提升\n![](http://img.yuekang.org.cn/2018061404.gif)\n\n\n## gc垃圾收集器\n\n下面是gc_globals的结构\n\n![](http://img.yuekang.org.cn/2018061802.png)\n\ngc_root_buffer 是一个双向链表，同时记录引用计数的相关信息，zend_gc_globals维护者gc的整个信息，这里列出个字段的含义。\n\n|序号|字段|含义|\n|:----    |:-------    |:--- |\n|1|gc_enabled|是否开启gc|\n|2|gc_active|垃圾回收算法是否运行|\n|3|gc_full|垃圾缓冲区是否满了，在debug模式下有用|\n|4|buf|垃圾缓冲区，PHP7默认大小为10 000个节点位置，0位置保留|\n|5|roots|指向缓冲区中最新加入的可能是垃圾的元素|\n|6|unused|指向缓冲区中没有使用的位置，在没有启动垃圾回收算法前，指向空|\n|7|first_unused|指向缓冲区中第一个未使用的位置，新的元素插入缓冲区后，指针会后移动一位|\n|8|last_unused|指向缓冲区中最后一个位置|\n|9|to_free|待释放的列表|\n|10|next_to_free|下一个待释放的列表|\n|11|gc_runs|记录gc算法的运行的次数，当缓冲区满了，才会运行gc算法|\n|12|collected|记录gc算法回收的垃圾数|\n\n\n## 垃圾收集过程\n\n1. 要求数据类型是数组和对象\n2. 没有在缓冲区中存在过\n3. 没有被标记过\n4. 将其gc_info标记为紫色的，且记录其在缓冲区的位置\n\n当缓冲区满时，再收集新的元素会出发垃圾回收算法。\n\n垃圾流转图：\n\n![](http://img.yuekang.org.cn/2018061801.png)\n\n回收过程分为4部分\n\n\n1. 对roots环中每一个元素进行深度优先遍历，将每个元素中gc_info为紫色的标记元素为灰色，且引用计数-1\n\n2. 扫描roots换中gc_info为灰色的元素，如果发现引用计数仍旧大于0，说明这个元素在其他地方使用，那么将其颜色重新标记为黑色，如果发现其引用计数是0则将其标记为白色，该过程同样为深度优先遍历。\n\n3. 扫描roots换，将gc_info颜色为黑色的的元素从roots移除，然后对roots中颜色为白色的元素进行深度有限遍历，将其引用计数+1，然后将roots链表移动到待释放列表中（to_free）中等待回收","slug":"2018-06-14-PHP7-垃圾回收机制","published":true,"updated":"2024-09-02T09:06:11.425Z","_id":"cm0oyp559001feesn0gm6bln5","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>垃圾回收是一种自动的内存管理机制，当一个变量在程序中不再被使用时，应该予以释放，这种内存资源管理称为垃圾回收。其中一种垃圾回收方式是使用引用计数，通过对数据存储的物理空间多附加一个计数器空间，当其他数据与其相关是，计数器加一，反之，相关解除时计数器减一。定期检查各存储对象的计数器，计数器为零的话，则认为该对象已经被抛弃而应将其所占物理空间回收。</p>\n</blockquote>\n<p>下面是GC的核心数据结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_refcounted</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> refcount;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_3(</span><br><span class=\"line\">                zend_uchar    type,</span><br><span class=\"line\">                zend_uchar    flags,</span><br><span class=\"line\">                <span class=\"type\">uint16_t</span>      gc_info)</span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> type_info;</span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://img.yuekang.org.cn/2018061401.png\" alt=\"zend_refcounted_h的结构\"></p>\n<p>zend_refcounted由32位bit的refcount和32bit的type_info组成</p>\n<p>\b1. type 第一个字节记录当前元素的类型</p>\n<ol start=\"2\">\n<li><p>flags 第二个字节用来记录数据类型</p>\n</li>\n<li><p>gc_info 后面的两个字节标记当前元素的颜色和垃圾回收池中的位置，其中高地址的两位用来标记颜色。</p>\n</li>\n</ol>\n<p>3.1 颜色有 黑色，白色，灰色，紫色</p>\n<p>php性能提升<br><img src=\"http://img.yuekang.org.cn/2018061404.gif\"></p>\n<h2 id=\"gc垃圾收集器\"><a href=\"#gc垃圾收集器\" class=\"headerlink\" title=\"gc垃圾收集器\"></a>gc垃圾收集器</h2><p>下面是gc_globals的结构</p>\n<p><img src=\"http://img.yuekang.org.cn/2018061802.png\"></p>\n<p>gc_root_buffer 是一个双向链表，同时记录引用计数的相关信息，zend_gc_globals维护者gc的整个信息，这里列出个字段的含义。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">字段</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">gc_enabled</td>\n<td align=\"left\">是否开启gc</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">gc_active</td>\n<td align=\"left\">垃圾回收算法是否运行</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">gc_full</td>\n<td align=\"left\">垃圾缓冲区是否满了，在debug模式下有用</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">buf</td>\n<td align=\"left\">垃圾缓冲区，PHP7默认大小为10 000个节点位置，0位置保留</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">roots</td>\n<td align=\"left\">指向缓冲区中最新加入的可能是垃圾的元素</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">unused</td>\n<td align=\"left\">指向缓冲区中没有使用的位置，在没有启动垃圾回收算法前，指向空</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">first_unused</td>\n<td align=\"left\">指向缓冲区中第一个未使用的位置，新的元素插入缓冲区后，指针会后移动一位</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">last_unused</td>\n<td align=\"left\">指向缓冲区中最后一个位置</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">to_free</td>\n<td align=\"left\">待释放的列表</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">next_to_free</td>\n<td align=\"left\">下一个待释放的列表</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">gc_runs</td>\n<td align=\"left\">记录gc算法的运行的次数，当缓冲区满了，才会运行gc算法</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">collected</td>\n<td align=\"left\">记录gc算法回收的垃圾数</td>\n</tr>\n</tbody></table>\n<h2 id=\"垃圾收集过程\"><a href=\"#垃圾收集过程\" class=\"headerlink\" title=\"垃圾收集过程\"></a>垃圾收集过程</h2><ol>\n<li>要求数据类型是数组和对象</li>\n<li>没有在缓冲区中存在过</li>\n<li>没有被标记过</li>\n<li>将其gc_info标记为紫色的，且记录其在缓冲区的位置</li>\n</ol>\n<p>当缓冲区满时，再收集新的元素会出发垃圾回收算法。</p>\n<p>垃圾流转图：</p>\n<p><img src=\"http://img.yuekang.org.cn/2018061801.png\"></p>\n<p>回收过程分为4部分</p>\n<ol>\n<li><p>对roots环中每一个元素进行深度优先遍历，将每个元素中gc_info为紫色的标记元素为灰色，且引用计数-1</p>\n</li>\n<li><p>扫描roots换中gc_info为灰色的元素，如果发现引用计数仍旧大于0，说明这个元素在其他地方使用，那么将其颜色重新标记为黑色，如果发现其引用计数是0则将其标记为白色，该过程同样为深度优先遍历。</p>\n</li>\n<li><p>扫描roots换，将gc_info颜色为黑色的的元素从roots移除，然后对roots中颜色为白色的元素进行深度有限遍历，将其引用计数+1，然后将roots链表移动到待释放列表中（to_free）中等待回收</p>\n</li>\n</ol>\n","excerpt":"","more":"<blockquote>\n<p>垃圾回收是一种自动的内存管理机制，当一个变量在程序中不再被使用时，应该予以释放，这种内存资源管理称为垃圾回收。其中一种垃圾回收方式是使用引用计数，通过对数据存储的物理空间多附加一个计数器空间，当其他数据与其相关是，计数器加一，反之，相关解除时计数器减一。定期检查各存储对象的计数器，计数器为零的话，则认为该对象已经被抛弃而应将其所占物理空间回收。</p>\n</blockquote>\n<p>下面是GC的核心数据结构:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">zend_refcounted</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> refcount;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            ZEND_ENDIAN_LOHI_3(</span><br><span class=\"line\">                zend_uchar    type,</span><br><span class=\"line\">                zend_uchar    flags,</span><br><span class=\"line\">                <span class=\"type\">uint16_t</span>      gc_info)</span><br><span class=\"line\">        &#125; v;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> type_info;</span><br><span class=\"line\">    &#125; u;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://img.yuekang.org.cn/2018061401.png\" alt=\"zend_refcounted_h的结构\"></p>\n<p>zend_refcounted由32位bit的refcount和32bit的type_info组成</p>\n<p>\b1. type 第一个字节记录当前元素的类型</p>\n<ol start=\"2\">\n<li><p>flags 第二个字节用来记录数据类型</p>\n</li>\n<li><p>gc_info 后面的两个字节标记当前元素的颜色和垃圾回收池中的位置，其中高地址的两位用来标记颜色。</p>\n</li>\n</ol>\n<p>3.1 颜色有 黑色，白色，灰色，紫色</p>\n<p>php性能提升<br><img src=\"http://img.yuekang.org.cn/2018061404.gif\"></p>\n<h2 id=\"gc垃圾收集器\"><a href=\"#gc垃圾收集器\" class=\"headerlink\" title=\"gc垃圾收集器\"></a>gc垃圾收集器</h2><p>下面是gc_globals的结构</p>\n<p><img src=\"http://img.yuekang.org.cn/2018061802.png\"></p>\n<p>gc_root_buffer 是一个双向链表，同时记录引用计数的相关信息，zend_gc_globals维护者gc的整个信息，这里列出个字段的含义。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">字段</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">gc_enabled</td>\n<td align=\"left\">是否开启gc</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">gc_active</td>\n<td align=\"left\">垃圾回收算法是否运行</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">gc_full</td>\n<td align=\"left\">垃圾缓冲区是否满了，在debug模式下有用</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">buf</td>\n<td align=\"left\">垃圾缓冲区，PHP7默认大小为10 000个节点位置，0位置保留</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">roots</td>\n<td align=\"left\">指向缓冲区中最新加入的可能是垃圾的元素</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">unused</td>\n<td align=\"left\">指向缓冲区中没有使用的位置，在没有启动垃圾回收算法前，指向空</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">first_unused</td>\n<td align=\"left\">指向缓冲区中第一个未使用的位置，新的元素插入缓冲区后，指针会后移动一位</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">last_unused</td>\n<td align=\"left\">指向缓冲区中最后一个位置</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">to_free</td>\n<td align=\"left\">待释放的列表</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">next_to_free</td>\n<td align=\"left\">下一个待释放的列表</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">gc_runs</td>\n<td align=\"left\">记录gc算法的运行的次数，当缓冲区满了，才会运行gc算法</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">collected</td>\n<td align=\"left\">记录gc算法回收的垃圾数</td>\n</tr>\n</tbody></table>\n<h2 id=\"垃圾收集过程\"><a href=\"#垃圾收集过程\" class=\"headerlink\" title=\"垃圾收集过程\"></a>垃圾收集过程</h2><ol>\n<li>要求数据类型是数组和对象</li>\n<li>没有在缓冲区中存在过</li>\n<li>没有被标记过</li>\n<li>将其gc_info标记为紫色的，且记录其在缓冲区的位置</li>\n</ol>\n<p>当缓冲区满时，再收集新的元素会出发垃圾回收算法。</p>\n<p>垃圾流转图：</p>\n<p><img src=\"http://img.yuekang.org.cn/2018061801.png\"></p>\n<p>回收过程分为4部分</p>\n<ol>\n<li><p>对roots环中每一个元素进行深度优先遍历，将每个元素中gc_info为紫色的标记元素为灰色，且引用计数-1</p>\n</li>\n<li><p>扫描roots换中gc_info为灰色的元素，如果发现引用计数仍旧大于0，说明这个元素在其他地方使用，那么将其颜色重新标记为黑色，如果发现其引用计数是0则将其标记为白色，该过程同样为深度优先遍历。</p>\n</li>\n<li><p>扫描roots换，将gc_info颜色为黑色的的元素从roots移除，然后对roots中颜色为白色的元素进行深度有限遍历，将其引用计数+1，然后将roots链表移动到待释放列表中（to_free）中等待回收</p>\n</li>\n</ol>\n","path":"2018/06/14/2018-06-14-PHP7-垃圾回收机制/","permalink":"https://yuekang.org.cn/2018/06/14/2018-06-14-PHP7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","tags":[{"name":"PHP","_id":"cm0oyp5570018eesnad2yex0s","slug":"PHP","path":"tags/PHP/","permalink":"https://yuekang.org.cn/tags/PHP/","length":10},{"name":"PHP7","_id":"cm0oyp55z003veesn0nxubwm0","slug":"PHP7","path":"tags/PHP7/","permalink":"https://yuekang.org.cn/tags/PHP7/","length":4},{"name":"垃圾回收","_id":"cm0oyp5600046eesn1jdx0snt","slug":"垃圾回收","path":"tags/垃圾回收/","permalink":"https://yuekang.org.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","length":1}],"categories":[],"prev":{"title":"array常用函数整理","date":"2018-06-19T14:25:39.000Z","slug":"2018-06-19-array常用函数整理","published":true,"updated":"2024-09-02T09:06:11.426Z","_id":"cm0oyp55a001heesndhrk2ue6","layout":"post","photos":[],"excerpt":"","path":"2018/06/19/2018-06-19-array常用函数整理/","permalink":"https://yuekang.org.cn/2018/06/19/2018-06-19-array%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/","__post":true},"next":{"title":"PHP7之线程安全","date":"2018-06-13T14:31:29.000Z","slug":"2018-06-13-PHP7之线程安全","published":true,"updated":"2024-09-02T09:06:11.425Z","_id":"cm0oyp558001deesn1zoqasoc","layout":"post","photos":[],"excerpt":"","path":"2018/06/13/2018-06-13-PHP7之线程安全/","permalink":"https://yuekang.org.cn/2018/06/13/2018-06-13-PHP7%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","__post":true},"__post":true}