{"title":"PHP7之线程安全","date":"2018-06-13T14:31:29.000Z","source":"_posts/2018-06-13.PHP7之线程安全.md","raw":"---\ntitle: PHP7之线程安全\ndate: 2018-06-13 22:31:29\ntags: [PHP,PHP7,线程安全]\n---\n\n>以前总觉得php是多进程单线程的，每个访问都是一个单独的进程互相不干扰\b各自的数据，数据是隔离的，最早的PHP都是来一个用户新建一个进程，访问结束就销毁这个进程，但是这样非常的浪费性能，后续PHP-fpm的出现将这个进程复用实现了，大大的优化速度，用户来了以后是分配一个线程的空闲进程来服务，用户离开就回到空闲里面给后面的用户使用。现在php早已实现了多线程的功能，今天我来学学这个多线程是怎么实现的。\n\n\n目前PHP多数是单线程环境，比如cli、fpm、cgi，每个进程只启动一个主线程，这种情况下也就不存在线程安全的情况了，在多线程环境下就需要考虑线程安全的问题了，PHP中有很多的全局变量这个如果多线程公用的情况下就会造成线程安全你的问题，PHP专门做了一个安全机制：Zend线程安全(Zend Thread Safe, ZTS)\n\nPHP为了解决这个问题做了一个程安全资源管理器(Thread Safe Resource Mananger, TSRM)，其主要实现的原理就是单个进程有一个公用的全局\b变量，如果多线程互相\b贡献不安全，就把这些数据拷贝若干份，保证每个线程都有自己的全局变量，这样线程之间互不干扰完美的解决这个安全的问题.\n\nPHP中定义如下：\n\n```C\ntypedef struct {\n    size_t size; //资源的大小\n    ts_allocate_ctor ctor; //初始化函数\n    ts_allocate_dtor dtor;\n    int done;\n} tsrm_resource_type;\n\nstruct _tsrm_tls_entry {\n    void **storage; //资源数组\n    int count; //拥有的资源数:storage数组大小\n    THREAD_T thread_id; //所属线程id\n    tsrm_tls_entry *next;\n};\n\n```\n一个资源如果想被多线程使用，就必须想TSRM\b注册资源，TSRM会给这个资源分配一个ID,并把资源相关数据初始化保存到`tsrm_resource_type`中去，\b所有的线程必须通过这个ID来访问这个资源，如果线程第一次访问这个资源，TSRM会初始化这个资源，也就是复制一份出来给这个线程使用包括后续访问。\n\n![PHP线程安全分配图表](http://img.yuekang.org.cn/blog/images/2018061301.png)\n\n\n`tsrm_tls_table` 保存着所有线程物理位置，这个位置通过根据线程id与预设置的线程数`tsrm_tls_table_size`取模得到的\n\n每个线程拥有一个`tsrm_tls_entry`结构，当前线程的所有资源保存在storage数组中，它是一个链表结构，查找资源时首先根据:线程id % tsrm_tls_table_size得到一个tsrm_tls_entry，然后开始遍历链表比较thread_id确定是否是当前线程的。\n线程本地存储(Thread Local Storage, TLS)，在创建完当前线程的tsrm_tls_entry后会把这个值保存到当前线程的TLS中，这样在ts_resource()获取资源时中就可以通过tsrm_tls_get()直接取到了，节省加锁检索的时间。","slug":"2018-06-13-PHP7之线程安全","published":true,"updated":"2024-09-08T06:12:12.685Z","_id":"cm0q19pf6001dw8sndfh5bp4g","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>以前总觉得php是多进程单线程的，每个访问都是一个单独的进程互相不干扰\b各自的数据，数据是隔离的，最早的PHP都是来一个用户新建一个进程，访问结束就销毁这个进程，但是这样非常的浪费性能，后续PHP-fpm的出现将这个进程复用实现了，大大的优化速度，用户来了以后是分配一个线程的空闲进程来服务，用户离开就回到空闲里面给后面的用户使用。现在php早已实现了多线程的功能，今天我来学学这个多线程是怎么实现的。</p>\n</blockquote>\n<p>目前PHP多数是单线程环境，比如cli、fpm、cgi，每个进程只启动一个主线程，这种情况下也就不存在线程安全的情况了，在多线程环境下就需要考虑线程安全的问题了，PHP中有很多的全局变量这个如果多线程公用的情况下就会造成线程安全你的问题，PHP专门做了一个安全机制：Zend线程安全(Zend Thread Safe, ZTS)</p>\n<p>PHP为了解决这个问题做了一个程安全资源管理器(Thread Safe Resource Mananger, TSRM)，其主要实现的原理就是单个进程有一个公用的全局\b变量，如果多线程互相\b贡献不安全，就把这些数据拷贝若干份，保证每个线程都有自己的全局变量，这样线程之间互不干扰完美的解决这个安全的问题.</p>\n<p>PHP中定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size; <span class=\"comment\">//资源的大小</span></span><br><span class=\"line\">    ts_allocate_ctor ctor; <span class=\"comment\">//初始化函数</span></span><br><span class=\"line\">    ts_allocate_dtor dtor;</span><br><span class=\"line\">    <span class=\"type\">int</span> done;</span><br><span class=\"line\">&#125; tsrm_resource_type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">tsrm_tls_entry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> **storage; <span class=\"comment\">//资源数组</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">//拥有的资源数:storage数组大小</span></span><br><span class=\"line\">    THREAD_T thread_id; <span class=\"comment\">//所属线程id</span></span><br><span class=\"line\">    tsrm_tls_entry *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>一个资源如果想被多线程使用，就必须想TSRM\b注册资源，TSRM会给这个资源分配一个ID,并把资源相关数据初始化保存到<code>tsrm_resource_type</code>中去，\b所有的线程必须通过这个ID来访问这个资源，如果线程第一次访问这个资源，TSRM会初始化这个资源，也就是复制一份出来给这个线程使用包括后续访问。</p>\n<p><img src=\"http://img.yuekang.org.cn/blog/images/2018061301.png\" alt=\"PHP线程安全分配图表\"></p>\n<p><code>tsrm_tls_table</code> 保存着所有线程物理位置，这个位置通过根据线程id与预设置的线程数<code>tsrm_tls_table_size</code>取模得到的</p>\n<p>每个线程拥有一个<code>tsrm_tls_entry</code>结构，当前线程的所有资源保存在storage数组中，它是一个链表结构，查找资源时首先根据:线程id % tsrm_tls_table_size得到一个tsrm_tls_entry，然后开始遍历链表比较thread_id确定是否是当前线程的。<br>线程本地存储(Thread Local Storage, TLS)，在创建完当前线程的tsrm_tls_entry后会把这个值保存到当前线程的TLS中，这样在ts_resource()获取资源时中就可以通过tsrm_tls_get()直接取到了，节省加锁检索的时间。</p>\n","excerpt":"","more":"<blockquote>\n<p>以前总觉得php是多进程单线程的，每个访问都是一个单独的进程互相不干扰\b各自的数据，数据是隔离的，最早的PHP都是来一个用户新建一个进程，访问结束就销毁这个进程，但是这样非常的浪费性能，后续PHP-fpm的出现将这个进程复用实现了，大大的优化速度，用户来了以后是分配一个线程的空闲进程来服务，用户离开就回到空闲里面给后面的用户使用。现在php早已实现了多线程的功能，今天我来学学这个多线程是怎么实现的。</p>\n</blockquote>\n<p>目前PHP多数是单线程环境，比如cli、fpm、cgi，每个进程只启动一个主线程，这种情况下也就不存在线程安全的情况了，在多线程环境下就需要考虑线程安全的问题了，PHP中有很多的全局变量这个如果多线程公用的情况下就会造成线程安全你的问题，PHP专门做了一个安全机制：Zend线程安全(Zend Thread Safe, ZTS)</p>\n<p>PHP为了解决这个问题做了一个程安全资源管理器(Thread Safe Resource Mananger, TSRM)，其主要实现的原理就是单个进程有一个公用的全局\b变量，如果多线程互相\b贡献不安全，就把这些数据拷贝若干份，保证每个线程都有自己的全局变量，这样线程之间互不干扰完美的解决这个安全的问题.</p>\n<p>PHP中定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> size; <span class=\"comment\">//资源的大小</span></span><br><span class=\"line\">    ts_allocate_ctor ctor; <span class=\"comment\">//初始化函数</span></span><br><span class=\"line\">    ts_allocate_dtor dtor;</span><br><span class=\"line\">    <span class=\"type\">int</span> done;</span><br><span class=\"line\">&#125; tsrm_resource_type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">tsrm_tls_entry</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> **storage; <span class=\"comment\">//资源数组</span></span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">//拥有的资源数:storage数组大小</span></span><br><span class=\"line\">    THREAD_T thread_id; <span class=\"comment\">//所属线程id</span></span><br><span class=\"line\">    tsrm_tls_entry *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>一个资源如果想被多线程使用，就必须想TSRM\b注册资源，TSRM会给这个资源分配一个ID,并把资源相关数据初始化保存到<code>tsrm_resource_type</code>中去，\b所有的线程必须通过这个ID来访问这个资源，如果线程第一次访问这个资源，TSRM会初始化这个资源，也就是复制一份出来给这个线程使用包括后续访问。</p>\n<p><img src=\"http://img.yuekang.org.cn/blog/images/2018061301.png\" alt=\"PHP线程安全分配图表\"></p>\n<p><code>tsrm_tls_table</code> 保存着所有线程物理位置，这个位置通过根据线程id与预设置的线程数<code>tsrm_tls_table_size</code>取模得到的</p>\n<p>每个线程拥有一个<code>tsrm_tls_entry</code>结构，当前线程的所有资源保存在storage数组中，它是一个链表结构，查找资源时首先根据:线程id % tsrm_tls_table_size得到一个tsrm_tls_entry，然后开始遍历链表比较thread_id确定是否是当前线程的。<br>线程本地存储(Thread Local Storage, TLS)，在创建完当前线程的tsrm_tls_entry后会把这个值保存到当前线程的TLS中，这样在ts_resource()获取资源时中就可以通过tsrm_tls_get()直接取到了，节省加锁检索的时间。</p>\n","path":"2018/06/13/2018-06-13-PHP7之线程安全/","permalink":"https://yuekang.org.cn/2018/06/13/2018-06-13-PHP7%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","tags":[{"name":"PHP","_id":"cm0q19pf40018w8snarzydr0l","slug":"PHP","path":"tags/PHP/","permalink":"https://yuekang.org.cn/tags/PHP/","length":10},{"name":"PHP7","_id":"cm0q19pfy003uw8snc7et0r2w","slug":"PHP7","path":"tags/PHP7/","permalink":"https://yuekang.org.cn/tags/PHP7/","length":4},{"name":"线程安全","_id":"cm0q19pfz0040w8snh6ep7d13","slug":"线程安全","path":"tags/线程安全/","permalink":"https://yuekang.org.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","length":1}],"categories":[],"prev":{"title":"PHP7-垃圾回收机制","date":"2018-06-14T13:30:01.000Z","slug":"2018-06-14-PHP7-垃圾回收机制","published":true,"updated":"2024-09-08T06:12:12.675Z","_id":"cm0q19pf7001fw8snc7z6fnl9","layout":"post","photos":[],"excerpt":"","path":"2018/06/14/2018-06-14-PHP7-垃圾回收机制/","permalink":"https://yuekang.org.cn/2018/06/14/2018-06-14-PHP7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","__post":true},"next":{"title":"PHP内存管理器机制","date":"2018-06-12T14:26:38.000Z","slug":"2018-06-12-PHP内存管理器机制","published":true,"updated":"2024-09-08T06:12:12.678Z","_id":"cm0q19pf5001bw8sndrzlae6m","layout":"post","photos":[],"excerpt":"","path":"2018/06/12/2018-06-12-PHP内存管理器机制/","permalink":"https://yuekang.org.cn/2018/06/12/2018-06-12-PHP%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8%E6%9C%BA%E5%88%B6/","__post":true},"__post":true}