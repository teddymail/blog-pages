{"title":"explain执行计划参数","date":"2024-09-08T14:26:51.000Z","source":"_posts/2024-09-08-explain执行计划参数记录.md","raw":"---\ntitle: explain执行计划参数\ndate: 2024-09-08 22:26:51\ntags: [mysql, 面试]\n---\n\n> 我们经常会遇到数据库优化相关内容 会使用explain 关键字对执行的sql进行查询计划分析，下面将对一些重要的指标进行记录。\n\n我们会经常使用exlain来进行查询优化分析，\n例如以下查询:\n```sql\nmysql> explain select * from kt_course order by create_time desc;\n+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+\n| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra          |\n+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+\n|  1 | SIMPLE      | kt_course | ALL  | NULL          | NULL | NULL    | NULL |   29 | Using filesort |\n+----+-------------+-----------+------+---------------+------+---------+------+------+----------------+\n1 row in set\n```\n\n我们可以看到有很多的参数\n* select_type 查询类型\n1. SIMPLE：简单的SELECT，不实用UNION或者子查询。\n2. PRIMARY：最外层SELECT。\n3. UNION：第二层，在SELECT之后使用了UNION。\n4. DEPENDENT UNION：UNION语句中的第二个SELECT，依赖于外部子查询。\n5. UNION RESULT：UNION的结果。\n6. SUBQUERY：子查询中的第一个SELECT。\n7. DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询。\n8. DERIVED：导出表的SELECT（FROM子句的子查询）\n  \n* table 查询的那张表\n\n显示这一行的数据是关于哪张表的\n\n* type 查询类型\n\n这是重要的列，显示连接使用了何种类型。\n从最好到最差的连接类型：const、eq_reg、ref、range、index和ALL\n\nType：告诉我们对表使用的访问方式，主要包含如下集中类型。\n\n1. all：全表扫描。\n2. const：读常量，最多只会有一条记录匹配，由于是常量，实际上只须要读一次。\n3. eq_ref：最多只会有一条匹配结果，一般是通过主键或唯一键索引来访问。\n4. fulltext：进行全文索引检索。\n5. index：全索引扫描。\n6. index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行合并（merge），再读取表数据。\n7. index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或唯一索引。\n8. rang：索引范围扫描。\n9. ref：Join语句中被驱动表索引引用的查询。\n10. ref_or_null：与ref的唯一区别就是在使用索引引用的查询之外再增加一个空值的查询。\n11. system：系统表，表中只有一行数据；\n12. unique_subquery：子查询中的返回结果字段组合是主键或唯一约束。\n\n* possible_keys 可能用到的索引\n\n显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句\n\n* key 使用的索引\n\n实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引\n\n* key_len\n\n使用的索引的长度。在不损失精确性的情况下，长度越短越好\n\n* ref\n  显示索引的哪一列被使用了，如果可能的话，是一个常数\n\n* rows\n\nMYSQL认为必须检查的用来返回请求数据的行数\n\n* Extra\n\n1. Extra：查询中每一步实现的额外细节信息，主要会是以下内容。\n2. Distinct：查找distinct 值，当mysql找到了第一条匹配的结果时，将停止该值的查询，转为后面其他值查询。\n3. Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用。\n4. Range checked for each record (index map: N)：通过 MySQL 官方手册的描述，当 MySQL Query Optimizer 没有发现好的可以使用的索引时，如果发现前面表的列值已知，部分索引可以使用。对前面表的每个行组合，MySQL检查是否可以使用range或 index_merge访问方法来索取行。\n5. SELECT tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段时，MySQL Query Optimizer 会通过索引直接一次定位到所需的数据行完成整个查询。当然，前提是在 Query 中不能有 GROUP BY 操作。如使用MIN()或MAX()的时候。\n6. Using filesort：当Query 中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。\n7. Using index：所需数据只需在 Index 即可全部获得，不须要再到表中取数据。\n8. Using index for group-by：数据访问和 Using index 一样，所需数据只须要读取索引，当Query 中使用GROUP BY或DISTINCT 子句时，如果分组字段也在索引中，Extra中的信息就会是 Using index for group-by。\n9. Using temporary：当 MySQL 在某些操作中必须使用临时表时，在 Extra 信息中就会出现Using temporary 。主要常见于 GROUP BY 和 ORDER BY 等操作中。\n10. Using where：如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where 信息。\n11. Using where with pushed condition：这是一个仅仅在 NDBCluster存储引擎中才会出现的信息，而且还须要通过打开 Condition Pushdown 优化功能才可能被使用。控制参数为 engine_condition_pushdown 。\n12. Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果。\n13. No tables：Query 语句中使用 FROM DUAL或不包含任何 FROM子句。\n14. Not exists：在某些左连接中，MySQL Query Optimizer通过改变原有 Query 的组成而使用的优化方法，可以部分减少数据访问次数。\n\n----\n非常感谢你得阅读！","slug":"explain执行计划参数记录","published":true,"updated":"2024-09-09T07:08:20.981Z","_id":"cm0w4eg1t0032etsnelg57c5w","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>我们经常会遇到数据库优化相关内容 会使用explain 关键字对执行的sql进行查询计划分析，下面将对一些重要的指标进行记录。</p>\n</blockquote>\n<p>我们会经常使用exlain来进行查询优化分析，<br>例如以下查询:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> kt_course <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> create_time <span class=\"keyword\">desc</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> id <span class=\"operator\">|</span> select_type <span class=\"operator\">|</span> <span class=\"keyword\">table</span>     <span class=\"operator\">|</span> type <span class=\"operator\">|</span> possible_keys <span class=\"operator\">|</span> key  <span class=\"operator\">|</span> key_len <span class=\"operator\">|</span> <span class=\"keyword\">ref</span>  <span class=\"operator\">|</span> <span class=\"keyword\">rows</span> <span class=\"operator\">|</span> Extra          <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">1</span> <span class=\"operator\">|</span> SIMPLE      <span class=\"operator\">|</span> kt_course <span class=\"operator\">|</span> <span class=\"keyword\">ALL</span>  <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>          <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>   <span class=\"number\">29</span> <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> filesort <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"type\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到有很多的参数</p>\n<ul>\n<li>select_type 查询类型</li>\n</ul>\n<ol>\n<li>SIMPLE：简单的SELECT，不实用UNION或者子查询。</li>\n<li>PRIMARY：最外层SELECT。</li>\n<li>UNION：第二层，在SELECT之后使用了UNION。</li>\n<li>DEPENDENT UNION：UNION语句中的第二个SELECT，依赖于外部子查询。</li>\n<li>UNION RESULT：UNION的结果。</li>\n<li>SUBQUERY：子查询中的第一个SELECT。</li>\n<li>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询。</li>\n<li>DERIVED：导出表的SELECT（FROM子句的子查询）</li>\n</ol>\n<ul>\n<li>table 查询的那张表</li>\n</ul>\n<p>显示这一行的数据是关于哪张表的</p>\n<ul>\n<li>type 查询类型</li>\n</ul>\n<p>这是重要的列，显示连接使用了何种类型。<br>从最好到最差的连接类型：const、eq_reg、ref、range、index和ALL</p>\n<p>Type：告诉我们对表使用的访问方式，主要包含如下集中类型。</p>\n<ol>\n<li>all：全表扫描。</li>\n<li>const：读常量，最多只会有一条记录匹配，由于是常量，实际上只须要读一次。</li>\n<li>eq_ref：最多只会有一条匹配结果，一般是通过主键或唯一键索引来访问。</li>\n<li>fulltext：进行全文索引检索。</li>\n<li>index：全索引扫描。</li>\n<li>index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行合并（merge），再读取表数据。</li>\n<li>index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或唯一索引。</li>\n<li>rang：索引范围扫描。</li>\n<li>ref：Join语句中被驱动表索引引用的查询。</li>\n<li>ref_or_null：与ref的唯一区别就是在使用索引引用的查询之外再增加一个空值的查询。</li>\n<li>system：系统表，表中只有一行数据；</li>\n<li>unique_subquery：子查询中的返回结果字段组合是主键或唯一约束。</li>\n</ol>\n<ul>\n<li>possible_keys 可能用到的索引</li>\n</ul>\n<p>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p>\n<ul>\n<li>key 使用的索引</li>\n</ul>\n<p>实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p>\n<ul>\n<li>key_len</li>\n</ul>\n<p>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>\n<ul>\n<li><p>ref<br>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>\n</li>\n<li><p>rows</p>\n</li>\n</ul>\n<p>MYSQL认为必须检查的用来返回请求数据的行数</p>\n<ul>\n<li>Extra</li>\n</ul>\n<ol>\n<li>Extra：查询中每一步实现的额外细节信息，主要会是以下内容。</li>\n<li>Distinct：查找distinct 值，当mysql找到了第一条匹配的结果时，将停止该值的查询，转为后面其他值查询。</li>\n<li>Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用。</li>\n<li>Range checked for each record (index map: N)：通过 MySQL 官方手册的描述，当 MySQL Query Optimizer 没有发现好的可以使用的索引时，如果发现前面表的列值已知，部分索引可以使用。对前面表的每个行组合，MySQL检查是否可以使用range或 index_merge访问方法来索取行。</li>\n<li>SELECT tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段时，MySQL Query Optimizer 会通过索引直接一次定位到所需的数据行完成整个查询。当然，前提是在 Query 中不能有 GROUP BY 操作。如使用MIN()或MAX()的时候。</li>\n<li>Using filesort：当Query 中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。</li>\n<li>Using index：所需数据只需在 Index 即可全部获得，不须要再到表中取数据。</li>\n<li>Using index for group-by：数据访问和 Using index 一样，所需数据只须要读取索引，当Query 中使用GROUP BY或DISTINCT 子句时，如果分组字段也在索引中，Extra中的信息就会是 Using index for group-by。</li>\n<li>Using temporary：当 MySQL 在某些操作中必须使用临时表时，在 Extra 信息中就会出现Using temporary 。主要常见于 GROUP BY 和 ORDER BY 等操作中。</li>\n<li>Using where：如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where 信息。</li>\n<li>Using where with pushed condition：这是一个仅仅在 NDBCluster存储引擎中才会出现的信息，而且还须要通过打开 Condition Pushdown 优化功能才可能被使用。控制参数为 engine_condition_pushdown 。</li>\n<li>Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果。</li>\n<li>No tables：Query 语句中使用 FROM DUAL或不包含任何 FROM子句。</li>\n<li>Not exists：在某些左连接中，MySQL Query Optimizer通过改变原有 Query 的组成而使用的优化方法，可以部分减少数据访问次数。</li>\n</ol>\n<hr>\n<p>非常感谢你得阅读！</p>\n","excerpt":"","more":"<blockquote>\n<p>我们经常会遇到数据库优化相关内容 会使用explain 关键字对执行的sql进行查询计划分析，下面将对一些重要的指标进行记录。</p>\n</blockquote>\n<p>我们会经常使用exlain来进行查询优化分析，<br>例如以下查询:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql<span class=\"operator\">&gt;</span> explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> kt_course <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> create_time <span class=\"keyword\">desc</span>;</span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span> id <span class=\"operator\">|</span> select_type <span class=\"operator\">|</span> <span class=\"keyword\">table</span>     <span class=\"operator\">|</span> type <span class=\"operator\">|</span> possible_keys <span class=\"operator\">|</span> key  <span class=\"operator\">|</span> key_len <span class=\"operator\">|</span> <span class=\"keyword\">ref</span>  <span class=\"operator\">|</span> <span class=\"keyword\">rows</span> <span class=\"operator\">|</span> Extra          <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class=\"line\"><span class=\"operator\">|</span>  <span class=\"number\">1</span> <span class=\"operator\">|</span> SIMPLE      <span class=\"operator\">|</span> kt_course <span class=\"operator\">|</span> <span class=\"keyword\">ALL</span>  <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>          <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span>    <span class=\"operator\">|</span> <span class=\"keyword\">NULL</span> <span class=\"operator\">|</span>   <span class=\"number\">29</span> <span class=\"operator\">|</span> <span class=\"keyword\">Using</span> filesort <span class=\"operator\">|</span></span><br><span class=\"line\"><span class=\"operator\">+</span><span class=\"comment\">----+-------------+-----------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"type\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到有很多的参数</p>\n<ul>\n<li>select_type 查询类型</li>\n</ul>\n<ol>\n<li>SIMPLE：简单的SELECT，不实用UNION或者子查询。</li>\n<li>PRIMARY：最外层SELECT。</li>\n<li>UNION：第二层，在SELECT之后使用了UNION。</li>\n<li>DEPENDENT UNION：UNION语句中的第二个SELECT，依赖于外部子查询。</li>\n<li>UNION RESULT：UNION的结果。</li>\n<li>SUBQUERY：子查询中的第一个SELECT。</li>\n<li>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询。</li>\n<li>DERIVED：导出表的SELECT（FROM子句的子查询）</li>\n</ol>\n<ul>\n<li>table 查询的那张表</li>\n</ul>\n<p>显示这一行的数据是关于哪张表的</p>\n<ul>\n<li>type 查询类型</li>\n</ul>\n<p>这是重要的列，显示连接使用了何种类型。<br>从最好到最差的连接类型：const、eq_reg、ref、range、index和ALL</p>\n<p>Type：告诉我们对表使用的访问方式，主要包含如下集中类型。</p>\n<ol>\n<li>all：全表扫描。</li>\n<li>const：读常量，最多只会有一条记录匹配，由于是常量，实际上只须要读一次。</li>\n<li>eq_ref：最多只会有一条匹配结果，一般是通过主键或唯一键索引来访问。</li>\n<li>fulltext：进行全文索引检索。</li>\n<li>index：全索引扫描。</li>\n<li>index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行合并（merge），再读取表数据。</li>\n<li>index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或唯一索引。</li>\n<li>rang：索引范围扫描。</li>\n<li>ref：Join语句中被驱动表索引引用的查询。</li>\n<li>ref_or_null：与ref的唯一区别就是在使用索引引用的查询之外再增加一个空值的查询。</li>\n<li>system：系统表，表中只有一行数据；</li>\n<li>unique_subquery：子查询中的返回结果字段组合是主键或唯一约束。</li>\n</ol>\n<ul>\n<li>possible_keys 可能用到的索引</li>\n</ul>\n<p>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p>\n<ul>\n<li>key 使用的索引</li>\n</ul>\n<p>实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p>\n<ul>\n<li>key_len</li>\n</ul>\n<p>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>\n<ul>\n<li><p>ref<br>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>\n</li>\n<li><p>rows</p>\n</li>\n</ul>\n<p>MYSQL认为必须检查的用来返回请求数据的行数</p>\n<ul>\n<li>Extra</li>\n</ul>\n<ol>\n<li>Extra：查询中每一步实现的额外细节信息，主要会是以下内容。</li>\n<li>Distinct：查找distinct 值，当mysql找到了第一条匹配的结果时，将停止该值的查询，转为后面其他值查询。</li>\n<li>Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用。</li>\n<li>Range checked for each record (index map: N)：通过 MySQL 官方手册的描述，当 MySQL Query Optimizer 没有发现好的可以使用的索引时，如果发现前面表的列值已知，部分索引可以使用。对前面表的每个行组合，MySQL检查是否可以使用range或 index_merge访问方法来索取行。</li>\n<li>SELECT tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段时，MySQL Query Optimizer 会通过索引直接一次定位到所需的数据行完成整个查询。当然，前提是在 Query 中不能有 GROUP BY 操作。如使用MIN()或MAX()的时候。</li>\n<li>Using filesort：当Query 中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。</li>\n<li>Using index：所需数据只需在 Index 即可全部获得，不须要再到表中取数据。</li>\n<li>Using index for group-by：数据访问和 Using index 一样，所需数据只须要读取索引，当Query 中使用GROUP BY或DISTINCT 子句时，如果分组字段也在索引中，Extra中的信息就会是 Using index for group-by。</li>\n<li>Using temporary：当 MySQL 在某些操作中必须使用临时表时，在 Extra 信息中就会出现Using temporary 。主要常见于 GROUP BY 和 ORDER BY 等操作中。</li>\n<li>Using where：如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where 信息。</li>\n<li>Using where with pushed condition：这是一个仅仅在 NDBCluster存储引擎中才会出现的信息，而且还须要通过打开 Condition Pushdown 优化功能才可能被使用。控制参数为 engine_condition_pushdown 。</li>\n<li>Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果。</li>\n<li>No tables：Query 语句中使用 FROM DUAL或不包含任何 FROM子句。</li>\n<li>Not exists：在某些左连接中，MySQL Query Optimizer通过改变原有 Query 的组成而使用的优化方法，可以部分减少数据访问次数。</li>\n</ol>\n<hr>\n<p>非常感谢你得阅读！</p>\n","path":"2024/09/08/explain执行计划参数记录/","permalink":"https://yuekang.org.cn/2024/09/08/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%8F%82%E6%95%B0%E8%AE%B0%E5%BD%95/","tags":[{"name":"面试","_id":"cm0w4eg0v000detsn48w0hah2","slug":"面试","path":"tags/面试/","permalink":"https://yuekang.org.cn/tags/%E9%9D%A2%E8%AF%95/","length":3},{"name":"mysql","_id":"cm0w4eg1q002tetsnb1509034","slug":"mysql","path":"tags/mysql/","permalink":"https://yuekang.org.cn/tags/mysql/","length":6}],"categories":[],"prev":{"title":"总结索引失效","date":"2024-09-09T09:12:20.000Z","slug":"总结索引失效","published":true,"updated":"2024-09-09T10:16:09.292Z","_id":"cm0w4eg1t0034etsn6eyc2bup","layout":"post","photos":[],"excerpt":"","path":"2024/09/09/总结索引失效/","permalink":"https://yuekang.org.cn/2024/09/09/%E6%80%BB%E7%BB%93%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/","__post":true},"next":{"title":"MySQL各模块的作用","date":"2024-09-06T06:00:01.000Z","slug":"MySQL各模块的作用","published":true,"updated":"2024-09-06T09:21:41.609Z","_id":"cm0w4eg1s0030etsna0zkf87w","layout":"post","photos":[],"excerpt":"","path":"2024/09/06/MySQL各模块的作用/","permalink":"https://yuekang.org.cn/2024/09/06/MySQL%E5%90%84%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8/","__post":true},"__post":true}