{"title":"总结索引失效","date":"2024-09-09T09:12:20.000Z","source":"_posts/2024-09-09-总结索引失效.md","raw":"---\ntitle: 总结索引失效\ndate: 2024-09-09 17:12:20\ntags: [mysql, 索引]\n---\n\n> 我们都知道针对搜索列需要增加索引来提高我们的查询效率，但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。\n> 一旦不注意就会导致数据库放弃索引采用全表搜索的问题产生，本文就是来总结怎么预防这种情况的？\n\n# 索引失效有哪些情况？\n\n![索引失效的情况](https://img.yuekang.org.cn/blog/images/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5.webp)\n\n\n# 索引存储结构长什么样？\n\nMyISAM 索引结构如下：\n\n![MyISAM索引结构](https://img.yuekang.org.cn/blog/images/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.webp)\n\nInnoDb 索引结构如下：\n\n![InnoDb索引结构](https://img.yuekang.org.cn/blog/images/InnoDb%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.webp)\n\n\n# 对索引使用左或者左右模糊匹配\n\n当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。\n\n比如下面的 like 语句，查询 name 后缀为「康」的用户，执行计划中的 type=ALL 就代表了全表扫描，而没有走索引。\n\n```sql\n// name 字段为二级索引\nselect * from t_user where name like '%康';\n```\n![放弃索引结果](https://img.yuekang.org.cn/blog/images/WX20240909-174818%402x.png)\n\n因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。\n\n![索引值存储](https://img.yuekang.org.cn/blog/images/WX20240909-175316%402x.png)\n\n# 对索引使用函数\n\n一些情况我们希望通过函数来达到我们的搜索目的但是恰恰这种方式会导致索引失效。\n\n比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：\n\n```sql\n// name 为二级索引\nselect * from t_user where length(name)=6;\n```\n\n这个时候type就会为All 走的全表扫描\n\n>为什么对索引使用函数，就无法走索引了呢？\n\n因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。\n\n> 不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\n\n举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。\n\n```sql\nalter table t_user add key idx_name_length ((length(name)));\n```\n这样就会针对于函数计算的内容从新建立一个索引这样就可以实现索引的利用了！\n\n# 对索引进行表达式计算\n\n下面这种对表达式进行计算的也是无法走索引的\n```sql\nexplain select * from t_user where id + 1 = 10;\n```\n\n> 为什么对索引进行表达式计算，就无法走索引了呢？\n\n原因跟对索引使用函数差不多。\n\n因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。\n\n# 对索引隐式类型转换\n\n如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。\n\n但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。\n\n> 为什么第一种会放弃索引？ 第二种就不会了呢？\n\n要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。\n\n* 如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；\n* 如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select \"10\" > \"9\"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么\"10\"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。\n\n**MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。**\n\n\n\n# 联合索引非最左匹配\n\n对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。\n\n那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。\n\n创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。\n\n联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。\n\n比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：\n```sql\nwhere a=1；\nwhere a=1 and b=2 and c=3；\nwhere a=1 and b=2；\n```\n\n需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。\n\n但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:\n\n```sql\nwhere b=2；\nwhere c=3；\nwhere b=2 and c=3；\n```\n\n> 为什么联合索引不遵循最左匹配原则就会失效？\n\n原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。\n\n也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。\n\n# WHERE 子句中的 OR\n\n在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\n\n举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。\n\n```sql\nselect * from t_user where id = 1 or age = 18;\n```\n\n这样的语句执行以后不会走索引的\n\n这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。\n\n> 如何解决？\n\n要解决办法很简单，将 age 字段设置为索引即可。\n\n# 总结\n\n---\n\n今天介绍了 6 种会发生索引失效的情况：\n\n* 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；\n* 当我们在查询条件中对索引列使用函数，就会导致索引失效。\n* 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。\n* MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。\n* 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。\n* 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\n\n\n","slug":"总结索引失效","published":true,"updated":"2024-09-09T10:16:09.292Z","_id":"cm0w4eg1t0034etsn6eyc2bup","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>我们都知道针对搜索列需要增加索引来提高我们的查询效率，但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。<br>一旦不注意就会导致数据库放弃索引采用全表搜索的问题产生，本文就是来总结怎么预防这种情况的？</p>\n</blockquote>\n<h1 id=\"索引失效有哪些情况？\"><a href=\"#索引失效有哪些情况？\" class=\"headerlink\" title=\"索引失效有哪些情况？\"></a>索引失效有哪些情况？</h1><p><img src=\"https://img.yuekang.org.cn/blog/images/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5.webp\" alt=\"索引失效的情况\"></p>\n<h1 id=\"索引存储结构长什么样？\"><a href=\"#索引存储结构长什么样？\" class=\"headerlink\" title=\"索引存储结构长什么样？\"></a>索引存储结构长什么样？</h1><p>MyISAM 索引结构如下：</p>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.webp\" alt=\"MyISAM索引结构\"></p>\n<p>InnoDb 索引结构如下：</p>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/InnoDb%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.webp\" alt=\"InnoDb索引结构\"></p>\n<h1 id=\"对索引使用左或者左右模糊匹配\"><a href=\"#对索引使用左或者左右模糊匹配\" class=\"headerlink\" title=\"对索引使用左或者左右模糊匹配\"></a>对索引使用左或者左右模糊匹配</h1><p>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。</p>\n<p>比如下面的 like 语句，查询 name 后缀为「康」的用户，执行计划中的 type&#x3D;ALL 就代表了全表扫描，而没有走索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> name 字段为二级索引</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> name <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%康&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/WX20240909-174818%402x.png\" alt=\"放弃索引结果\"></p>\n<p>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/WX20240909-175316%402x.png\" alt=\"索引值存储\"></p>\n<h1 id=\"对索引使用函数\"><a href=\"#对索引使用函数\" class=\"headerlink\" title=\"对索引使用函数\"></a>对索引使用函数</h1><p>一些情况我们希望通过函数来达到我们的搜索目的但是恰恰这种方式会导致索引失效。</p>\n<p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> name 为二级索引</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> length(name)<span class=\"operator\">=</span><span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候type就会为All 走的全表扫描</p>\n<blockquote>\n<p>为什么对索引使用函数，就无法走索引了呢？</p>\n</blockquote>\n<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>\n<blockquote>\n<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>\n</blockquote>\n<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> t_user <span class=\"keyword\">add</span> key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>\n<p>这样就会针对于函数计算的内容从新建立一个索引这样就可以实现索引的利用了！</p>\n<h1 id=\"对索引进行表达式计算\"><a href=\"#对索引进行表达式计算\" class=\"headerlink\" title=\"对索引进行表达式计算\"></a>对索引进行表达式计算</h1><p>下面这种对表达式进行计算的也是无法走索引的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> id <span class=\"operator\">+</span> <span class=\"number\">1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么对索引进行表达式计算，就无法走索引了呢？</p>\n</blockquote>\n<p>原因跟对索引使用函数差不多。</p>\n<p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p>\n<h1 id=\"对索引隐式类型转换\"><a href=\"#对索引隐式类型转换\" class=\"headerlink\" title=\"对索引隐式类型转换\"></a>对索引隐式类型转换</h1><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p>\n<p>但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。</p>\n<blockquote>\n<p>为什么第一种会放弃索引？ 第二种就不会了呢？</p>\n</blockquote>\n<p>要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。</p>\n<ul>\n<li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li>\n<li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li>\n</ul>\n<p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。</strong></p>\n<h1 id=\"联合索引非最左匹配\"><a href=\"#联合索引非最左匹配\" class=\"headerlink\" title=\"联合索引非最左匹配\"></a>联合索引非最左匹配</h1><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>\n<p>那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。</p>\n<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>\n<p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。</p>\n<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">where</span> a<span class=\"operator\">=</span><span class=\"number\">1</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> a<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">and</span> b<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">and</span> c<span class=\"operator\">=</span><span class=\"number\">3</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> a<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">and</span> b<span class=\"operator\">=</span><span class=\"number\">2</span>；</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>\n<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">where</span> b<span class=\"operator\">=</span><span class=\"number\">2</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> c<span class=\"operator\">=</span><span class=\"number\">3</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> b<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">and</span> c<span class=\"operator\">=</span><span class=\"number\">3</span>；</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么联合索引不遵循最左匹配原则就会失效？</p>\n</blockquote>\n<p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>\n<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p>\n<h1 id=\"WHERE-子句中的-OR\"><a href=\"#WHERE-子句中的-OR\" class=\"headerlink\" title=\"WHERE 子句中的 OR\"></a>WHERE 子句中的 OR</h1><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>\n<p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">or</span> age <span class=\"operator\">=</span> <span class=\"number\">18</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这样的语句执行以后不会走索引的</p>\n<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>\n<blockquote>\n<p>如何解决？</p>\n</blockquote>\n<p>要解决办法很简单，将 age 字段设置为索引即可。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><hr>\n<p>今天介绍了 6 种会发生索引失效的情况：</p>\n<ul>\n<li>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</li>\n<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>\n<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>\n<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>\n<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>\n<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>我们都知道针对搜索列需要增加索引来提高我们的查询效率，但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。<br>一旦不注意就会导致数据库放弃索引采用全表搜索的问题产生，本文就是来总结怎么预防这种情况的？</p>\n</blockquote>\n<h1 id=\"索引失效有哪些情况？\"><a href=\"#索引失效有哪些情况？\" class=\"headerlink\" title=\"索引失效有哪些情况？\"></a>索引失效有哪些情况？</h1><p><img src=\"https://img.yuekang.org.cn/blog/images/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5.webp\" alt=\"索引失效的情况\"></p>\n<h1 id=\"索引存储结构长什么样？\"><a href=\"#索引存储结构长什么样？\" class=\"headerlink\" title=\"索引存储结构长什么样？\"></a>索引存储结构长什么样？</h1><p>MyISAM 索引结构如下：</p>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.webp\" alt=\"MyISAM索引结构\"></p>\n<p>InnoDb 索引结构如下：</p>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/InnoDb%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.webp\" alt=\"InnoDb索引结构\"></p>\n<h1 id=\"对索引使用左或者左右模糊匹配\"><a href=\"#对索引使用左或者左右模糊匹配\" class=\"headerlink\" title=\"对索引使用左或者左右模糊匹配\"></a>对索引使用左或者左右模糊匹配</h1><p>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。</p>\n<p>比如下面的 like 语句，查询 name 后缀为「康」的用户，执行计划中的 type&#x3D;ALL 就代表了全表扫描，而没有走索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> name 字段为二级索引</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> name <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%康&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/WX20240909-174818%402x.png\" alt=\"放弃索引结果\"></p>\n<p>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>\n<p><img src=\"https://img.yuekang.org.cn/blog/images/WX20240909-175316%402x.png\" alt=\"索引值存储\"></p>\n<h1 id=\"对索引使用函数\"><a href=\"#对索引使用函数\" class=\"headerlink\" title=\"对索引使用函数\"></a>对索引使用函数</h1><p>一些情况我们希望通过函数来达到我们的搜索目的但是恰恰这种方式会导致索引失效。</p>\n<p>比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type&#x3D;ALL，代表了全表扫描：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">/</span><span class=\"operator\">/</span> name 为二级索引</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> length(name)<span class=\"operator\">=</span><span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候type就会为All 走的全表扫描</p>\n<blockquote>\n<p>为什么对索引使用函数，就无法走索引了呢？</p>\n</blockquote>\n<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>\n<blockquote>\n<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>\n</blockquote>\n<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> t_user <span class=\"keyword\">add</span> key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>\n<p>这样就会针对于函数计算的内容从新建立一个索引这样就可以实现索引的利用了！</p>\n<h1 id=\"对索引进行表达式计算\"><a href=\"#对索引进行表达式计算\" class=\"headerlink\" title=\"对索引进行表达式计算\"></a>对索引进行表达式计算</h1><p>下面这种对表达式进行计算的也是无法走索引的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> id <span class=\"operator\">+</span> <span class=\"number\">1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么对索引进行表达式计算，就无法走索引了呢？</p>\n</blockquote>\n<p>原因跟对索引使用函数差不多。</p>\n<p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p>\n<h1 id=\"对索引隐式类型转换\"><a href=\"#对索引隐式类型转换\" class=\"headerlink\" title=\"对索引隐式类型转换\"></a>对索引隐式类型转换</h1><p>如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。</p>\n<p>但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。</p>\n<blockquote>\n<p>为什么第一种会放弃索引？ 第二种就不会了呢？</p>\n</blockquote>\n<p>要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。</p>\n<ul>\n<li>如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</li>\n<li>如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么”10”字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。</li>\n</ul>\n<p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。</strong></p>\n<h1 id=\"联合索引非最左匹配\"><a href=\"#联合索引非最左匹配\" class=\"headerlink\" title=\"联合索引非最左匹配\"></a>联合索引非最左匹配</h1><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>\n<p>那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。</p>\n<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>\n<p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。</p>\n<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">where</span> a<span class=\"operator\">=</span><span class=\"number\">1</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> a<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">and</span> b<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">and</span> c<span class=\"operator\">=</span><span class=\"number\">3</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> a<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">and</span> b<span class=\"operator\">=</span><span class=\"number\">2</span>；</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>\n<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">where</span> b<span class=\"operator\">=</span><span class=\"number\">2</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> c<span class=\"operator\">=</span><span class=\"number\">3</span>；</span><br><span class=\"line\"><span class=\"keyword\">where</span> b<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">and</span> c<span class=\"operator\">=</span><span class=\"number\">3</span>；</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么联合索引不遵循最左匹配原则就会失效？</p>\n</blockquote>\n<p>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>\n<p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p>\n<h1 id=\"WHERE-子句中的-OR\"><a href=\"#WHERE-子句中的-OR\" class=\"headerlink\" title=\"WHERE 子句中的 OR\"></a>WHERE 子句中的 OR</h1><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>\n<p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t_user <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">or</span> age <span class=\"operator\">=</span> <span class=\"number\">18</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这样的语句执行以后不会走索引的</p>\n<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>\n<blockquote>\n<p>如何解决？</p>\n</blockquote>\n<p>要解决办法很简单，将 age 字段设置为索引即可。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><hr>\n<p>今天介绍了 6 种会发生索引失效的情况：</p>\n<ul>\n<li>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</li>\n<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li>\n<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li>\n<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>\n<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>\n<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>\n</ul>\n","path":"2024/09/09/总结索引失效/","permalink":"https://yuekang.org.cn/2024/09/09/%E6%80%BB%E7%BB%93%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/","tags":[{"name":"mysql","_id":"cm0w4eg1q002tetsnb1509034","slug":"mysql","path":"tags/mysql/","permalink":"https://yuekang.org.cn/tags/mysql/","length":6},{"name":"索引","_id":"cm0w4eg2e008hetsn5qod7uzu","slug":"索引","path":"tags/索引/","permalink":"https://yuekang.org.cn/tags/%E7%B4%A2%E5%BC%95/","length":1}],"categories":[],"prev":{"title":"mysql事务隔离级别","date":"2024-09-10T02:57:49.000Z","slug":"mysql事务隔离级别","published":true,"updated":"2024-09-10T07:39:22.172Z","_id":"cm0w4eg1u0036etsnh12ado42","layout":"post","photos":[],"excerpt":"","path":"2024/09/10/mysql事务隔离级别/","permalink":"https://yuekang.org.cn/2024/09/10/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","__post":true},"next":{"title":"explain执行计划参数","date":"2024-09-08T14:26:51.000Z","slug":"explain执行计划参数记录","published":true,"updated":"2024-09-09T07:08:20.981Z","_id":"cm0w4eg1t0032etsnelg57c5w","layout":"post","photos":[],"excerpt":"","path":"2024/09/08/explain执行计划参数记录/","permalink":"https://yuekang.org.cn/2024/09/08/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%8F%82%E6%95%B0%E8%AE%B0%E5%BD%95/","__post":true},"__post":true}