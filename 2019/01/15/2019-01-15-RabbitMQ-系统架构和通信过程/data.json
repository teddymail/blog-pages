{"title":"RabbitMQ 系统架构和通信过程","date":"2019-01-15T14:55:18.000Z","source":"_posts/2019-01-15._RabbitMQ_系统架构和通信过程.md","raw":"---\ntitle:  RabbitMQ 系统架构和通信过程\ndate: 2019-01-15 22:55:18\ntags: [Rabbitmq,Queue]\n---\n\n> MQ全称为Message Queue, 是一种分布式应用程序的的通信方法，它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息。RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。\n\n## RabbitMQ简介\n\nRabbitMQ是一个由Erlang开发的AMQP（AdvancedMessage Queue ）的开源实现，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。\n\nRabbitmq系统最核心的组件是Exchange和Queue，下图是系统简单的示意图。Exchange和Queue是在rabbitmq Server\n\n![RabbitMQ系统示意图](http://img.yuekang.org.cn/2019011501.jpg)\n\n\n## AMQP 简介\n\nAMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。\n\n\n\n## Message Broker与AMQP简介\nMessage Broker是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景：\n\n1. 消息路由到一个或多个目的地\n\n2. 消息转化为其他的表现方式\n\n3. 执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户\n\n4. 调用Web服务来检索数据\n\n5. 响应事件或错误\n\n6. 使用发布-订阅模式来提供内容或基于主题的消息路由\n\nAMQP是Advanced Message QueuingProtocol的简称，它是一个面向消息中间件的开放式标准应用层协议。AMQP定义了这些特性：\n\n1. 消息方向\n\n2. 消息队列\n\n3. 消息路由（包括：点到点和发布-订阅模式）\n\n4. 可靠性\n\n5. 安全性\n\nRabbitMQ就是以AMQP协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。\n\n## Rabbitmq系统架构\n\nRabbitmq系统最核心的组件是Exchange和Queue，下图是系统简单的示意图。Exchange和Queue是在rabbitmq server（又叫做broker）端，producer和consumer在应用端。\n\n\n![结构图](http://img.yuekang.org.cn/2019011701.png)\n\n\n\b1. Producer 生产者\n2. Consumer 消费者\n3. Queue\n消息队列，提供了FIFO的处理机制，具有缓存消息的能力。rabbitmq中，队列消息可以设置为持久化，临时或者自动删除。\n\n设置为持久化的队列，queue中的消息会在server本地硬盘存储一份，防止系统crash，数据丢失\n设置为临时队列，queue中的数据在系统重启之后就会丢失\n设置为自动删除的队列，当不存在用户连接到server，队列中的数据会被自动删除\n\n4. Exchange\nExchange类似于数据通信网络中的交换机，提供消息路由策略。rabbitmq中，producer不是通过信道直接将消息发送给queue，而是先发送给Exchange。一个Exchange可以和多个Queue进行绑定，producer在传递消息的时候，会传递一个ROUTING_KEY，Exchange会根据这个ROUTING_KEY按照特定的路由算法，将消息路由给指定的queue。和Queue一样，Exchange也可设置为持久化，临时或者自动删除。\n\nExchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别\n\n4.1. Direct\n直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue\n\n![](http://img.yuekang.org.cn/2019011704.png)\n\n4.2. fanout\n广播是式交换器，不管消息的ROUTING_KEY设置为什么，Exchange都会将消息转发给所有绑定的Queue。\n\n![](http://img.yuekang.org.cn/2019011703.png)\n\n4.3 topic\n主题交换器，工作方式类似于组播，Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，比如，ROUTING_KEY为user.stock的Message会转发给绑定匹配模式为 * .stock,user.stock， * . * 和#.user.stock.#的队列。（ * 表是匹配一个任意词组，#表示匹配0个或多个词组）\n\n![](http://img.yuekang.org.cn/2019011705.png)\n\n\n4.4. headers\n消息体的header匹配（ignore）\n\n\n\n5. Binding\n\n所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。\n\n6. Virtual host\n\n在rabbitmq server上可以创建多个虚拟的message broker，又叫做virtual hosts (vhosts)。每一个vhost本质上是一个mini-rabbitmq server，分别管理各自的exchange，和bindings。vhost相当于物理的server，可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。producer和consumer连接rabbit server需要指定一个vhost。\n\n\n## 通信过程\n\n假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示：\n\n![示意图](http://img.yuekang.org.cn/2019011702.png)\n\nP1生产消息，发送给服务器端的Exchange\nExchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1\nQueue1收到消息，将消息发送给订阅者C1\nC1收到消息，发送ACK给队列确认收到消息\nQueue1收到ACK，删除队列中缓存的此条消息\n\nConsumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况：\n\n如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。\n如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。\n如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。\nrabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。\n","slug":"2019-01-15-RabbitMQ-系统架构和通信过程","published":true,"updated":"2024-09-02T09:06:11.432Z","_id":"cm0oplawr002muysn2oa0g8l5","comments":true,"layout":"post","photos":[],"html":"<blockquote>\n<p>MQ全称为Message Queue, 是一种分布式应用程序的的通信方法，它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息。RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。</p>\n</blockquote>\n<h2 id=\"RabbitMQ简介\"><a href=\"#RabbitMQ简介\" class=\"headerlink\" title=\"RabbitMQ简介\"></a>RabbitMQ简介</h2><p>RabbitMQ是一个由Erlang开发的AMQP（AdvancedMessage Queue ）的开源实现，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>Rabbitmq系统最核心的组件是Exchange和Queue，下图是系统简单的示意图。Exchange和Queue是在rabbitmq Server</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011501.jpg\" alt=\"RabbitMQ系统示意图\"></p>\n<h2 id=\"AMQP-简介\"><a href=\"#AMQP-简介\" class=\"headerlink\" title=\"AMQP 简介\"></a>AMQP 简介</h2><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。</p>\n<h2 id=\"Message-Broker与AMQP简介\"><a href=\"#Message-Broker与AMQP简介\" class=\"headerlink\" title=\"Message Broker与AMQP简介\"></a>Message Broker与AMQP简介</h2><p>Message Broker是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景：</p>\n<ol>\n<li><p>消息路由到一个或多个目的地</p>\n</li>\n<li><p>消息转化为其他的表现方式</p>\n</li>\n<li><p>执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户</p>\n</li>\n<li><p>调用Web服务来检索数据</p>\n</li>\n<li><p>响应事件或错误</p>\n</li>\n<li><p>使用发布-订阅模式来提供内容或基于主题的消息路由</p>\n</li>\n</ol>\n<p>AMQP是Advanced Message QueuingProtocol的简称，它是一个面向消息中间件的开放式标准应用层协议。AMQP定义了这些特性：</p>\n<ol>\n<li><p>消息方向</p>\n</li>\n<li><p>消息队列</p>\n</li>\n<li><p>消息路由（包括：点到点和发布-订阅模式）</p>\n</li>\n<li><p>可靠性</p>\n</li>\n<li><p>安全性</p>\n</li>\n</ol>\n<p>RabbitMQ就是以AMQP协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。</p>\n<h2 id=\"Rabbitmq系统架构\"><a href=\"#Rabbitmq系统架构\" class=\"headerlink\" title=\"Rabbitmq系统架构\"></a>Rabbitmq系统架构</h2><p>Rabbitmq系统最核心的组件是Exchange和Queue，下图是系统简单的示意图。Exchange和Queue是在rabbitmq server（又叫做broker）端，producer和consumer在应用端。</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011701.png\" alt=\"结构图\"></p>\n<p>\b1. Producer 生产者<br>2. Consumer 消费者<br>3. Queue<br>消息队列，提供了FIFO的处理机制，具有缓存消息的能力。rabbitmq中，队列消息可以设置为持久化，临时或者自动删除。</p>\n<p>设置为持久化的队列，queue中的消息会在server本地硬盘存储一份，防止系统crash，数据丢失<br>设置为临时队列，queue中的数据在系统重启之后就会丢失<br>设置为自动删除的队列，当不存在用户连接到server，队列中的数据会被自动删除</p>\n<ol start=\"4\">\n<li>Exchange<br>Exchange类似于数据通信网络中的交换机，提供消息路由策略。rabbitmq中，producer不是通过信道直接将消息发送给queue，而是先发送给Exchange。一个Exchange可以和多个Queue进行绑定，producer在传递消息的时候，会传递一个ROUTING_KEY，Exchange会根据这个ROUTING_KEY按照特定的路由算法，将消息路由给指定的queue。和Queue一样，Exchange也可设置为持久化，临时或者自动删除。</li>\n</ol>\n<p>Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别</p>\n<p>4.1. Direct<br>直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011704.png\"></p>\n<p>4.2. fanout<br>广播是式交换器，不管消息的ROUTING_KEY设置为什么，Exchange都会将消息转发给所有绑定的Queue。</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011703.png\"></p>\n<p>4.3 topic<br>主题交换器，工作方式类似于组播，Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，比如，ROUTING_KEY为user.stock的Message会转发给绑定匹配模式为 * .stock,user.stock， * . * 和#.user.stock.#的队列。（ * 表是匹配一个任意词组，#表示匹配0个或多个词组）</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011705.png\"></p>\n<p>4.4. headers<br>消息体的header匹配（ignore）</p>\n<ol start=\"5\">\n<li>Binding</li>\n</ol>\n<p>所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。</p>\n<ol start=\"6\">\n<li>Virtual host</li>\n</ol>\n<p>在rabbitmq server上可以创建多个虚拟的message broker，又叫做virtual hosts (vhosts)。每一个vhost本质上是一个mini-rabbitmq server，分别管理各自的exchange，和bindings。vhost相当于物理的server，可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。producer和consumer连接rabbit server需要指定一个vhost。</p>\n<h2 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h2><p>假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示：</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011702.png\" alt=\"示意图\"></p>\n<p>P1生产消息，发送给服务器端的Exchange<br>Exchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1<br>Queue1收到消息，将消息发送给订阅者C1<br>C1收到消息，发送ACK给队列确认收到消息<br>Queue1收到ACK，删除队列中缓存的此条消息</p>\n<p>Consumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况：</p>\n<p>如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。<br>如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。<br>如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。<br>rabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。</p>\n","excerpt":"","more":"<blockquote>\n<p>MQ全称为Message Queue, 是一种分布式应用程序的的通信方法，它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息。RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。</p>\n</blockquote>\n<h2 id=\"RabbitMQ简介\"><a href=\"#RabbitMQ简介\" class=\"headerlink\" title=\"RabbitMQ简介\"></a>RabbitMQ简介</h2><p>RabbitMQ是一个由Erlang开发的AMQP（AdvancedMessage Queue ）的开源实现，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>Rabbitmq系统最核心的组件是Exchange和Queue，下图是系统简单的示意图。Exchange和Queue是在rabbitmq Server</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011501.jpg\" alt=\"RabbitMQ系统示意图\"></p>\n<h2 id=\"AMQP-简介\"><a href=\"#AMQP-简介\" class=\"headerlink\" title=\"AMQP 简介\"></a>AMQP 简介</h2><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。</p>\n<h2 id=\"Message-Broker与AMQP简介\"><a href=\"#Message-Broker与AMQP简介\" class=\"headerlink\" title=\"Message Broker与AMQP简介\"></a>Message Broker与AMQP简介</h2><p>Message Broker是一种消息验证、传输、路由的架构模式，其设计目标主要应用于下面这些场景：</p>\n<ol>\n<li><p>消息路由到一个或多个目的地</p>\n</li>\n<li><p>消息转化为其他的表现方式</p>\n</li>\n<li><p>执行消息的聚集、消息的分解，并将结果发送到他们的目的地，然后重新组合相应返回给消息用户</p>\n</li>\n<li><p>调用Web服务来检索数据</p>\n</li>\n<li><p>响应事件或错误</p>\n</li>\n<li><p>使用发布-订阅模式来提供内容或基于主题的消息路由</p>\n</li>\n</ol>\n<p>AMQP是Advanced Message QueuingProtocol的简称，它是一个面向消息中间件的开放式标准应用层协议。AMQP定义了这些特性：</p>\n<ol>\n<li><p>消息方向</p>\n</li>\n<li><p>消息队列</p>\n</li>\n<li><p>消息路由（包括：点到点和发布-订阅模式）</p>\n</li>\n<li><p>可靠性</p>\n</li>\n<li><p>安全性</p>\n</li>\n</ol>\n<p>RabbitMQ就是以AMQP协议实现的一种中间件产品，它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。</p>\n<h2 id=\"Rabbitmq系统架构\"><a href=\"#Rabbitmq系统架构\" class=\"headerlink\" title=\"Rabbitmq系统架构\"></a>Rabbitmq系统架构</h2><p>Rabbitmq系统最核心的组件是Exchange和Queue，下图是系统简单的示意图。Exchange和Queue是在rabbitmq server（又叫做broker）端，producer和consumer在应用端。</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011701.png\" alt=\"结构图\"></p>\n<p>\b1. Producer 生产者<br>2. Consumer 消费者<br>3. Queue<br>消息队列，提供了FIFO的处理机制，具有缓存消息的能力。rabbitmq中，队列消息可以设置为持久化，临时或者自动删除。</p>\n<p>设置为持久化的队列，queue中的消息会在server本地硬盘存储一份，防止系统crash，数据丢失<br>设置为临时队列，queue中的数据在系统重启之后就会丢失<br>设置为自动删除的队列，当不存在用户连接到server，队列中的数据会被自动删除</p>\n<ol start=\"4\">\n<li>Exchange<br>Exchange类似于数据通信网络中的交换机，提供消息路由策略。rabbitmq中，producer不是通过信道直接将消息发送给queue，而是先发送给Exchange。一个Exchange可以和多个Queue进行绑定，producer在传递消息的时候，会传递一个ROUTING_KEY，Exchange会根据这个ROUTING_KEY按照特定的路由算法，将消息路由给指定的queue。和Queue一样，Exchange也可设置为持久化，临时或者自动删除。</li>\n</ol>\n<p>Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别</p>\n<p>4.1. Direct<br>直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011704.png\"></p>\n<p>4.2. fanout<br>广播是式交换器，不管消息的ROUTING_KEY设置为什么，Exchange都会将消息转发给所有绑定的Queue。</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011703.png\"></p>\n<p>4.3 topic<br>主题交换器，工作方式类似于组播，Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，比如，ROUTING_KEY为user.stock的Message会转发给绑定匹配模式为 * .stock,user.stock， * . * 和#.user.stock.#的队列。（ * 表是匹配一个任意词组，#表示匹配0个或多个词组）</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011705.png\"></p>\n<p>4.4. headers<br>消息体的header匹配（ignore）</p>\n<ol start=\"5\">\n<li>Binding</li>\n</ol>\n<p>所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。</p>\n<ol start=\"6\">\n<li>Virtual host</li>\n</ol>\n<p>在rabbitmq server上可以创建多个虚拟的message broker，又叫做virtual hosts (vhosts)。每一个vhost本质上是一个mini-rabbitmq server，分别管理各自的exchange，和bindings。vhost相当于物理的server，可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。producer和consumer连接rabbit server需要指定一个vhost。</p>\n<h2 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h2><p>假设P1和C1注册了相同的Broker，Exchange和Queue。P1发送的消息最终会被C1消费。基本的通信流程大概如下所示：</p>\n<p><img src=\"http://img.yuekang.org.cn/2019011702.png\" alt=\"示意图\"></p>\n<p>P1生产消息，发送给服务器端的Exchange<br>Exchange收到消息，根据ROUTINKEY，将消息转发给匹配的Queue1<br>Queue1收到消息，将消息发送给订阅者C1<br>C1收到消息，发送ACK给队列确认收到消息<br>Queue1收到ACK，删除队列中缓存的此条消息</p>\n<p>Consumer收到消息时需要显式的向rabbit broker发送basic.ack消息或者consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况：</p>\n<p>如果consumer接收了消息，发送ack,rabbitmq会删除队列中这个消息，发送另一条消息给consumer。<br>如果cosumer接受了消息, 但在发送ack之前断开连接，rabbitmq会认为这条消息没有被deliver,在consumer在次连接的时候，这条消息会被redeliver。<br>如果consumer接受了消息，但是程序中有bug,忘记了ack,rabbitmq不会重复发送消息。<br>rabbitmq2.0.0和之后的版本支持consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目地，那么rabbitmq将会把消息发送给下一个注册的consumer。</p>\n","path":"2019/01/15/2019-01-15-RabbitMQ-系统架构和通信过程/","permalink":"https://yuekang.org.cn/2019/01/15/2019-01-15-RabbitMQ-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%92%8C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/","tags":[{"name":"Rabbitmq","_id":"cm0oplax9006xuysnbqe8do9x","slug":"Rabbitmq","path":"tags/Rabbitmq/","permalink":"https://yuekang.org.cn/tags/Rabbitmq/","length":1},{"name":"Queue","_id":"cm0oplax90070uysn67ta8ecv","slug":"Queue","path":"tags/Queue/","permalink":"https://yuekang.org.cn/tags/Queue/","length":1}],"categories":[],"prev":{"title":"docker三大件之镜像学习","date":"2019-01-16T04:27:23.000Z","slug":"2019-01-16-docker三大件之镜像学习","published":true,"updated":"2024-09-02T09:06:11.432Z","_id":"cm0oplaws002ouysn32ju2say","layout":"post","photos":[],"excerpt":"","path":"2019/01/16/2019-01-16-docker三大件之镜像学习/","permalink":"https://yuekang.org.cn/2019/01/16/2019-01-16-docker%E4%B8%89%E5%A4%A7%E4%BB%B6%E4%B9%8B%E9%95%9C%E5%83%8F%E5%AD%A6%E4%B9%A0/","__post":true},"next":{"title":"Centos 端口转发管理","date":"2018-12-14T02:12:47.000Z","slug":"2018-12-14-Centos-端口转发管理","published":true,"updated":"2024-09-02T09:06:11.431Z","_id":"cm0oplawr002juysn4bgtgtrp","layout":"post","photos":[],"excerpt":"","path":"2018/12/14/2018-12-14-Centos-端口转发管理/","permalink":"https://yuekang.org.cn/2018/12/14/2018-12-14-Centos-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%AE%A1%E7%90%86/","__post":true},"__post":true}